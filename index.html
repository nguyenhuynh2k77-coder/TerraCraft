<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>TerraCraft HD - Ultimate Fix</title>
    <style>
        html, body { width: 100%; height: 100%; margin: 0; padding: 0; background: #000; overflow: hidden; touch-action: none; user-select: none; -webkit-user-select: none; }
        canvas { display: block; }
        #debug { position: absolute; top: 0; left: 0; color: #0f0; font-family: monospace; padding: 5px; pointer-events: none; }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.80.0/dist/phaser.min.js"></script>
</head>
<body>
<div id="debug">Initializing...</div>
<script>
window.onload = function() {
    // --- CẤU HÌNH ---
    const CFG = {
        TILE: 32, W: 300, H: 80,
        GRAVITY: 1200, WALK: 120, RUN: 240, JUMP: -500,
        SPAWN_RATE: 5000, MAX_MOBS: 10, // Giảm nhẹ max mobs để ổn định
        DROP_LIFETIME: 60000 // Đồ rơi tự biến mất sau 60s
    };

    const ID = {
        AIR:-1, DIRT:0, GRASS:1, STONE:2, COAL_ORE:3, IRON_ORE:4, GOLD_ORE:5, DIAMOND_ORE:6,
        LOG:7, LEAVES:8, TORCH:9, WORKBENCH:10, FURNACE:11, BRICK:12, PLANKS:13, ANVIL:14,
        SAPLING:15, SLIME_BLOCK:16, SAND:17, CACTUS:18, SNOW:19, CHEST:20, CAMPFIRE:21, BED:22,
        DOOR_CLOSED:23, DOOR_OPEN:24,
        RAW_IRON:100, RAW_GOLD:101, COAL:102, IRON_INGOT:103, GOLD_INGOT:104, SLIMEBALL:105,
        GOLDEN_APPLE:106, APPLE:107, DIAMOND:108, DOOR_ITEM:109,
        WOOD_PICK:200, WOOD_AXE:201, WOOD_SWORD:202
    };

    const GAME = {
        hp: 100, maxHp: 100, hunger: 100, maxHunger: 100,
        xp: 0, level: 1, inv: Array(10).fill(null), slot: 0,
        dead: false, mining: 0, input: { l:0, r:0, j:0, atk:0, use:0, drop:0 },
        dirtyUI: true // Cờ đánh dấu cần vẽ lại UI
    };
    GAME.inv[0] = { id: ID.WOOD_SWORD, count: 1 };
    GAME.inv[1] = { id: ID.APPLE, count: 5 };

    // --- ASSET GENERATOR (HD GRAPHICS) ---
    class AssetGen {
        static init(scene) {
            const g = scene.make.graphics({x:0,y:0,add:false});
            const drawBlock = (idx, color, noise=0.1) => {
                g.clear(); g.fillStyle(color); g.fillRect(0,0,32,32);
                g.fillStyle(0x000000, noise); for(let i=0;i<20;i++) g.fillRect(Math.random()*30,Math.random()*30,2,2);
                g.lineStyle(2,0xFFFFFF,0.2); g.strokeRect(1,1,30,30); // Bevel Light
                g.fillStyle(0x000000,0.3); g.fillRect(0,30,32,2); g.fillRect(30,0,2,32); // Bevel Shadow
                g.generateTexture('b_'+idx,32,32);
            };

            // Blocks
            drawBlock(ID.DIRT, 0x795548, 0.15);
            drawBlock(ID.STONE, 0x808080, 0.2);
            drawBlock(ID.SAND, 0xE6D690, 0.1);
            drawBlock(ID.SNOW, 0xFFFFFF, 0.05);
            drawBlock(ID.LOG, 0x5D4037, 0.3);
            drawBlock(ID.PLANKS, 0xA1887F, 0.05);
            drawBlock(ID.BRICK, 0x757575, 0.1);
            drawBlock(ID.WORKBENCH, 0x8D6E63); drawBlock(ID.FURNACE, 0x424242);
            
            // Grass
            g.clear(); g.fillStyle(0x795548); g.fillRect(0,0,32,32); 
            g.fillStyle(0x4CAF50); g.fillRect(0,0,32,12);
            g.generateTexture('b_'+ID.GRASS, 32, 32);

            // Ores
            const ore = (id, base, gem) => {
                drawBlock(id, base, 0.2);
                const t = scene.textures.get('b_'+id);
                const c = t.getSourceImage().getContext('2d');
                c.fillStyle = gem; 
                for(let i=0;i<5;i++) c.fillRect(6+Math.random()*20, 6+Math.random()*20, 5, 5);
                t.refresh();
            };
            ore(ID.COAL_ORE,0x808080,'#222'); ore(ID.IRON_ORE,0x808080,'#E0C0A0'); 
            ore(ID.GOLD_ORE,0x808080,'#FFD700'); ore(ID.DIAMOND_ORE,0x808080,'#00FFFF');

            // Complex Blocks
            g.clear(); g.fillStyle(0x388E3C); g.fillRect(0,0,32,32); g.fillStyle(0x66BB6A); 
            for(let i=0;i<20;i++) g.fillRect(Math.random()*28,Math.random()*28,4,4);
            g.generateTexture('b_'+ID.LEAVES, 32, 32);

            g.clear(); g.fillStyle(0x2E7D32); g.fillRect(4,0,24,32); g.fillStyle(0x1B5E20); for(let i=4;i<32;i+=4) g.fillRect(4,i,2,2); g.generateTexture('b_'+ID.CACTUS,32,32);
            
            g.clear(); g.fillStyle(0xA1887F); g.fillRect(4,0,24,32); g.lineStyle(2,0x5D4037); g.strokeRect(4,0,24,32); g.fillStyle(0xFFD700); g.fillCircle(22,16,2); g.generateTexture('b_'+ID.DOOR_CLOSED,32,32);
            g.clear(); g.fillStyle(0x5D4037); g.fillRect(2,0,6,32); g.generateTexture('b_'+ID.DOOR_OPEN,32,32);

            // Items
            const item = (n, c) => { g.clear(); g.fillStyle(c); g.fillCircle(16,16,10); g.lineStyle(2,0xFFFFFF); g.strokeCircle(16,16,10); g.generateTexture(n,32,32); };
            item('i_apple', 0xD50000); item('i_tool', 0x8D6E63); item('i_slime', 0x76FF03); item('i_mat', 0xAAAAAA);

            // Mobs
            g.clear(); g.fillStyle(0xFBC02D); g.fillRect(8,0,16,10); g.fillStyle(0x0288D1); g.fillRect(8,10,16,12); g.fillStyle(0x1A237E); g.fillRect(8,22,16,10); g.generateTexture('player',32,32);
            g.clear(); g.fillStyle(0x4CAF50,0.8); g.fillRect(4,10,24,22); g.fillStyle(0x1B5E20); g.fillRect(8,15,4,4); g.fillRect(20,15,4,4); g.generateTexture('slime',32,32);

            // Particles
            g.clear(); g.fillStyle(0x64B5F6); g.fillRect(0,0,3,8); g.generateTexture('rain',3,8);
            g.clear(); g.fillStyle(0xFFFFFF); g.fillRect(0,0,4,4); g.generateTexture('snow',4,4);
        }
    }

    // --- GAME SCENE ---
    class GameScene extends Phaser.Scene {
        constructor() { super('Game'); }
        preload() { AssetGen.init(this); }
        
        create() {
            this.W = CFG.W * CFG.TILE; this.H = CFG.H * CFG.TILE;
            this.physics.world.setBounds(0, 0, this.W, this.H);
            
            // Sky Gradient
            this.sky = this.add.graphics();
            
            // Tilemap setup using Atlas technique for performance
            const map = this.make.tilemap({ tileWidth: 32, tileHeight: 32, width: CFG.W, height: CFG.H });
            // Create a dynamic tileset from generated textures
            const totalIDs = 30;
            const atlas = this.textures.createCanvas('atlas', totalIDs*32, 32);
            const ctx = atlas.getContext();
            for(let id=0; id<totalIDs; id++) {
                if(this.textures.exists('b_'+id)) ctx.drawImage(this.textures.get('b_'+id).getSourceImage(), id*32, 0);
            }
            atlas.refresh();
            
            const tileset = map.addTilesetImage('atlas', null, 32, 32);
            this.ground = map.createBlankLayer('G', tileset);
            this.obj = map.createBlankLayer('O', tileset);
            this.ground.setCollisionByExclusion([-1]);
            this.obj.setCollision([ID.SLIME_BLOCK, ID.CACTUS, ID.DOOR_CLOSED]);

            this.genMap();

            // Player
            this.p = this.physics.add.sprite(200, 0, 'player').setDepth(10);
            this.p.body.setSize(14, 28).setOffset(9, 2);
            this.physics.add.collider(this.p, this.ground);
            this.physics.add.collider(this.p, this.obj, (p,t)=>{ if(t.index===ID.CACTUS) this.hurt(1); });

            this.cameras.main.startFollow(this.p, true, 0.1, 0.1).setZoom(1.4).setBounds(0,0,this.W,this.H);
            this.hand = this.add.sprite(0,0,'i_tool').setDepth(11).setVisible(false).setScale(0.6);

            // Objects
            this.drops = this.physics.add.group({dragX:500, bounceY:0.2});
            this.physics.add.collider(this.drops, this.ground);
            this.physics.add.overlap(this.p, this.drops, (p,d)=>this.pickup(d));

            this.mobs = this.physics.add.group();
            this.physics.add.collider(this.mobs, this.ground);
            this.physics.add.collider(this.mobs, this.obj, (m,t)=>{ if(t.index===ID.CACTUS) this.mobHurt(m,5); });
            this.physics.add.overlap(this.p, this.mobs, (p,m)=>this.hitByMob(m));

            // Particles (Single Manager)
            this.rain = this.add.particles(0,0,'rain',{speedY:{min:300,max:500}, quantity:1, frequency:50, emitting:false});
            this.snow = this.add.particles(0,0,'snow',{speedY:{min:50,max:100}, quantity:1, frequency:100, emitting:false});
            
            this.marker = this.add.rectangle(0,0,32,32).setStrokeStyle(2,0xFFFF00).setVisible(false);
            
            // Input
            this.cursors = this.input.keyboard.createCursorKeys();
            this.keys = this.input.keyboard.addKeys('E,Q,ONE,TWO,THREE,FOUR,FIVE,SIX,SEVEN,EIGHT');

            this.time.addEvent({delay: CFG.SPAWN_RATE, callback: this.spawnMob, callbackScope: this, loop: true});
            this.scene.launch('UI');
            document.getElementById('debug').innerText = "Game Running";
        }

        genMap() {
            const set = (l,x,y,id) => { const t=l.putTileAt(id,x,y); t.index=id; }; // Helper
            for(let x=0; x<CFG.W; x++) {
                let h = 40 + Math.floor(Math.sin(x/15)*10 + Math.cos(x/5)*5);
                for(let y=0; y<CFG.H; y++) {
                    if(y===h) set(this.ground, x, y, x<100?ID.GRASS:(x>200?ID.SNOW:ID.SAND));
                    else if(y>h) set(this.ground, x, y, y>h+5?ID.STONE:ID.DIRT);
                }
                if(x%5===0 && Math.random()<0.3) {
                    if(x<100) { set(this.obj, x, h-1, ID.LOG); set(this.obj, x, h-2, ID.LEAVES); }
                    else if(x>100 && x<200) set(this.obj, x, h-1, ID.CACTUS);
                }
            }
        }

        update(time, delta) {
            if(GAME.dead) return;

            // Environment
            const cycle = (time % CFG.DAY_LEN) / CFG.DAY_LEN;
            const isDay = cycle > 0.25 && cycle < 0.75;
            this.sky.clear();
            this.sky.fillGradientStyle(isDay?0x87CEEB:0x000022, isDay?0x87CEEB:0x000022, isDay?0xDDF3F9:0x000000, isDay?0xDDF3F9:0x000000, 1);
            this.sky.fillRect(0,0,this.scale.width, this.scale.height);

            const px = this.p.x;
            // Di chuyển Emitter thay vì tạo mới Rect
            const camW = 800; 
            this.rain.setEmitZone({source: new Phaser.Geom.Rectangle(px - camW/2, -100, camW, 1)});
            this.snow.setEmitZone({source: new Phaser.Geom.Rectangle(px - camW/2, -100, camW, 1)});
            
            if(px < 3200) { this.rain.start(); this.snow.stop(); }
            else if(px > 6400) { this.snow.start(); this.rain.stop(); }
            else { this.rain.stop(); this.snow.stop(); }

            // Physics logic
            const spd = this.keys.SHIFT?.isDown ? CFG.RUN : CFG.WALK;
            if(this.cursors.left.isDown || GAME.input.l) { this.p.setVelocityX(-spd); this.p.setFlipX(true); }
            else if(this.cursors.right.isDown || GAME.input.r) { this.p.setVelocityX(spd); this.p.setFlipX(false); }
            else this.p.setVelocityX(0);
            
            if((this.cursors.up.isDown || GAME.input.j) && this.p.body.onFloor()) this.p.setVelocityY(CFG.JUMP);

            // Hand
            const item = GAME.inv[GAME.slot];
            if(item) {
                this.hand.setVisible(true).setTexture(item.id<100?'b_'+item.id:'i_tool');
                this.hand.setPosition(this.p.x + (this.p.flipX?-12:12), this.p.y+5);
            } else this.hand.setVisible(false);

            this.handleInput();

            // AI Loop (Tối ưu)
            this.mobs.children.iterate(m => {
                if(m && m.body) {
                    if(Math.abs(m.x - this.p.x) < 300) m.setVelocityX(this.p.x > m.x ? 80 : -80);
                    if(m.body.onFloor() && Math.random()<0.01) m.setVelocityY(-300);
                }
            });
            
            // Clean up Drops (Chống tràn RAM)
            this.drops.children.iterate(d => {
                if(d && time > d.getData('dieTime')) d.destroy();
            });

            GAME.input.atk=0; GAME.input.use=0; GAME.input.drop=0;
        }

        handleInput() {
            const ptr = this.input.activePointer;
            const wp = ptr.positionToCamera(this.cameras.main);
            let tx = Math.floor(wp.x/32), ty = Math.floor(wp.y/32);
            if(GAME.input.atk || GAME.input.use) {
                tx = Math.floor((this.p.x+(this.p.flipX?-32:32))/32); ty = Math.floor(this.p.y/32);
            }
            this.marker.setPosition(tx*32, ty*32).setVisible(true);

            // MINE
            if((ptr.isDown && !this.lastP) || GAME.input.atk) {
                let hit = false;
                this.mobs.children.iterate(m => {
                    if(m && Phaser.Geom.Rectangle.Overlaps(m.getBounds(), this.marker.getBounds())) {
                        this.mobHurt(m, 5); hit=true;
                    }
                });
                if(!hit) {
                    const t = this.obj.getTileAt(tx,ty) || this.ground.getTileAt(tx,ty);
                    if(t) {
                        GAME.mining++; this.hand.angle = this.p.flipX ? -45 : 45;
                        if(GAME.mining > 15) {
                            this.dropItem(tx*32, ty*32, t.index);
                            if(t.tilemapLayer===this.obj) this.obj.removeTileAt(tx,ty); else this.ground.removeTileAt(tx,ty);
                            GAME.mining=0;
                        }
                    }
                }
            } else { this.hand.angle = 0; GAME.mining = 0; }

            // PLACE / USE
            if((ptr.rightButtonDown() && !this.lastR) || GAME.input.use) {
                const item = GAME.inv[GAME.slot];
                const tObj = this.obj.getTileAt(tx, ty);
                
                if(tObj && tObj.index === ID.DOOR_CLOSED) {
                    this.obj.putTileAt(ID.DOOR_OPEN, tx, ty).setCollision(false);
                } else if(tObj && tObj.index === ID.DOOR_OPEN) {
                    this.obj.putTileAt(ID.DOOR_CLOSED, tx, ty).setCollision(true);
                }
                else if(item && item.id < 100 && !tObj) {
                    if(!Phaser.Geom.Rectangle.Overlaps(this.p.getBounds(), this.marker.getBounds())) {
                        if(item.id === ID.CACTUS) {
                            const bot = this.ground.getTileAt(tx, ty+1);
                            if(bot && bot.index === ID.SAND) { this.obj.putTileAt(ID.CACTUS, tx, ty); this.consume(); }
                        } else if(item.id === ID.DOOR_ITEM) {
                            this.obj.putTileAt(ID.DOOR_CLOSED, tx, ty); this.consume();
                        } else {
                            this.obj.putTileAt(item.id, tx, ty); this.consume();
                        }
                    }
                }
            }
            // Drop
            if(GAME.input.drop) {
                const it = GAME.inv[GAME.slot];
                if(it) { this.dropItem(this.p.x, this.p.y-20, it.id); this.consume(); }
            }

            // Keyboard Slots
            for(let i=0; i<9; i++) if(this.keys[['ONE','TWO','THREE','FOUR','FIVE','SIX','SEVEN','EIGHT','NINE'][i]].isDown) { GAME.slot = i; GAME.dirtyUI = true; }

            this.lastP = ptr.isDown; this.lastR = ptr.rightButtonDown();
        }

        consume() {
            const i = GAME.inv[GAME.slot];
            if(i) { i.count--; if(i.count<=0) GAME.inv[GAME.slot] = null; GAME.dirtyUI = true; }
        }

        dropItem(x, y, id) {
            let tex = 'i_mat';
            if(id<100) tex = 'b_'+id;
            else if(id===ID.SLIMEBALL) tex = 'i_slime';
            else if(id===ID.APPLE) tex = 'i_apple';
            
            const d = this.drops.create(x, y, tex).setDisplaySize(16,16);
            d.setData('id', id).setData('t', this.time.now + 1000).setData('dieTime', this.time.now + CFG.DROP_LIFETIME);
            d.setVelocity(Math.random()*100-50, -200);
        }

        pickup(d) {
            if(this.time.now < d.getData('t') || GAME.dead) return;
            const id = d.getData('id');
            let done = false;
            // Stack
            for(let i=0; i<10; i++) if(GAME.inv[i] && GAME.inv[i].id === id) { GAME.inv[i].count++; done=true; break; }
            // New
            if(!done) for(let i=0; i<10; i++) if(!GAME.inv[i]) { GAME.inv[i]={id:id, count:1}; done=true; break; }
            
            if(done) { d.destroy(); GAME.dirtyUI = true; }
        }

        spawnMob() {
            if(this.mobs.countActive() < CFG.MAX_MOBS && !GAME.dead) {
                const x = Phaser.Math.Between(0, this.W);
                if(Math.abs(x - this.p.x) > 400) {
                    const m = this.mobs.create(x, 100, 'slime').setBounce(0.5).setCollideWorldBounds(true);
                    m.hp = 20;
                }
            }
        }

        mobHurt(m, d) {
            m.hp -= d; m.setTint(0xFF0000); m.setVelocityY(-200);
            this.time.delayedCall(150, ()=>m.clearTint());
            if(m.hp <= 0) { this.dropItem(m.x, m.y, ID.SLIMEBALL); m.destroy(); }
        }

        hitByMob(m) { this.hurt(10); m.setVelocityX(m.x>this.p.x?100:-100); }

        hurt(d) {
            if(GAME.dead) return;
            GAME.hp -= d; GAME.dirtyUI = true;
            this.cameras.main.shake(100, 0.01);
            if(GAME.hp <= 0) {
                GAME.dead = true;
                this.p.setTint(0xFF0000);
                GAME.inv.forEach((it,i) => {
                    if(it) {
                        for(let k=0;k<it.count;k++) this.dropItem(this.p.x, this.p.y, it.id);
                        GAME.inv[i] = null;
                    }
                });
                this.scene.get('UI').showDeath(true);
            }
        }

        respawn() {
            GAME.dead = false; GAME.hp = 100; GAME.dirtyUI = true;
            this.p.clearTint().setPosition(200,0).setVelocity(0,0);
            this.scene.get('UI').showDeath(false);
        }
    }

    // --- UI SCENE (SMART UPDATE) ---
    class UIScene extends Phaser.Scene {
        constructor() { super('UI'); }
        create() {
            const W = this.scale.width, H = this.scale.height;
            // Bars
            this.add.text(10, 10, 'HP', {fontSize:12});
            this.hpBar = this.add.rectangle(35, 18, 150, 12, 0xFF0000).setOrigin(0);
            this.add.rectangle(35, 18, 150, 12).setStrokeStyle(1, 0xFFFFFF).setOrigin(0);

            // Slots
            this.slots = [];
            const sx = (W - 10*36)/2;
            for(let i=0; i<10; i++) {
                const c = this.add.container(sx + i*36, H-40);
                const bg = this.add.rectangle(0,0,32,32,0x222222).setStrokeStyle(1, 0x888888);
                const ico = this.add.image(0,0,'i_tool').setDisplaySize(20,20).setVisible(false);
                const txt = this.add.text(8,8,'',{fontSize:10}).setOrigin(1);
                c.add([bg, ico, txt]);
                c.setInteractive(new Phaser.Geom.Rectangle(-16,-16,32,32), Phaser.Geom.Rectangle.Contains)
                 .on('pointerdown', ()=> { GAME.slot=i; GAME.dirtyUI=true; });
                this.slots.push({bg, ico, txt});
            }

            // Controls
            const btn = (x,y,t,fn) => this.add.text(x,y,t,{fontSize:20, backgroundColor:'#333', padding:{x:8,y:8}}).setOrigin(0.5).setInteractive().on('pointerdown',fn);
            btn(40, H-50, '<', ()=>GAME.input.l=1).on('pointerup', ()=>GAME.input.l=0);
            btn(90, H-50, '>', ()=>GAME.input.r=1).on('pointerup', ()=>GAME.input.r=0);
            btn(W-40, H-50, '^', ()=>GAME.input.j=1).on('pointerup', ()=>GAME.input.j=0);
            btn(W-90, H-50, 'A', ()=>GAME.input.atk=1);
            btn(W-40, H-100, 'U', ()=>GAME.input.use=1);
            btn(W-90, H-100, 'D', ()=>GAME.input.drop=1);

            // Death Screen
            this.deathPnl = this.add.container(W/2, H/2).setVisible(false);
            this.deathPnl.add([
                this.add.rectangle(0,0,W,H,0x000000,0.8),
                this.add.text(0,-30,'YOU DIED', {fontSize:40, color:'red'}).setOrigin(0.5),
                this.add.text(0,30,'[ RESPAWN ]', {fontSize:20}).setOrigin(0.5).setInteractive().on('pointerdown', ()=>this.scene.get('Game').respawn())
            ]);
        }

        showDeath(v) { this.deathPnl.setVisible(v); }

        update() {
            // FIX CRASH: Only update if Dirty Flag is true
            if(GAME.dirtyUI) {
                this.hpBar.width = (GAME.hp/GAME.maxHp)*150;
                for(let i=0; i<10; i++) {
                    const s = this.slots[i];
                    const it = GAME.inv[i];
                    s.bg.setStrokeStyle(2, GAME.slot===i ? 0x00FF00 : 0x888888);
                    if(it) {
                        let tex = 'i_mat';
                        if(it.id<100) tex = 'b_'+it.id;
                        else if(it.id===ID.WOOD_SWORD) tex = 'i_tool';
                        else if(it.id===ID.APPLE) tex = 'i_apple';
                        else if(it.id===ID.SLIMEBALL) tex = 'i_slime';
                        else if(it.id===ID.DOOR_ITEM) tex = 'b_'+ID.DOOR_CLOSED;
                        
                        s.ico.setVisible(true).setTexture(tex);
                        s.txt.setText(it.count>1 ? it.count : '');
                    } else {
                        s.ico.setVisible(false); s.txt.setText('');
                    }
                }
                GAME.dirtyUI = false; // Reset flag
            }
        }
    }

    new Phaser.Game({
        type: Phaser.AUTO,
        scale: { mode: Phaser.Scale.RESIZE, parent: document.body, width: '100%', height: '100%' },
        pixelArt: true,
        physics: { default: 'arcade', arcade: { gravity: { y: CFG.GRAVITY } } },
        scene: [GameScene, UIScene]
    });
};
</script>
</body>
</html>
