<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>OpenGeode v25.4 - World Size Selection</title>
    <style>
        body { margin: 0; overflow: hidden; background: #222; font-family: 'Courier New', monospace; user-select: none; }
        canvas { display: block; }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.80.0/dist/phaser.min.js"></script>
</head>
<body>

<script>
// --- CẤU HÌNH ---
const TILE_SIZE = 32;
let WORLD_WIDTH = 300; // Mặc định, sẽ thay đổi theo lựa chọn
const WORLD_HEIGHT = 80;

const SPAWN_CONFIG = { INTERVAL: 3000, MAX_SLIMES: 15, MIN_DIST: 400 };
const REGEN_CONFIG = { DELAY: 5000, RATE: 1000, AMOUNT: 5 };

const SURVIVAL_CONFIG = {
    HUNGER_DECAY_RATE: 15000, 
    STARVATION_DAMAGE: 5,
    XP_PER_ORE: 10,
    XP_PER_KILL: 50,
    BASE_XP_REQ: 100
};

const PHYSICS_CONFIG = {
    GRAVITY: 1400, WALK_SPEED: 110, RUN_SPEED: 230, 
    JUMP_FORCE: -520, BOOST_JUMP: -750, SLIME_BOUNCE: -900, 
    FALL_SAFE_VELOCITY: 750 
};

// Định nghĩa ID
const BLOCKS = { 
    AIR: -1, 
    DIRT: 0, GRASS: 1, STONE: 2, COAL_ORE: 3, IRON_ORE: 4, GOLD_ORE: 5, DIAMOND_ORE: 6,
    LOG: 7, LEAVES: 8, TORCH: 9, WORKBENCH: 10, FURNACE: 11, BRICK: 12, PLANKS: 13, ANVIL: 14, SAPLING: 15,
    SLIME_BLOCK: 16, SAND: 17, CACTUS: 18, SNOW: 19, CHEST: 20, CAMPFIRE: 21, BED: 22,
    
    RAW_IRON: 100, RAW_GOLD: 101, COAL: 102, IRON_INGOT: 103, GOLD_INGOT: 104, SLIMEBALL: 105,
    GOLDEN_APPLE: 106, APPLE: 107, DIAMOND: 108,
    
    WOOD_PICKAXE: 200, WOOD_AXE: 201, WOOD_SWORD: 202,
    STONE_PICKAXE: 210, STONE_AXE: 211, STONE_SWORD: 212,
    IRON_PICKAXE: 220, IRON_AXE: 221, IRON_SHOVEL: 222, IRON_SWORD: 223, SHEARS: 224,
    SLIME_BOOTS: 230
};

const MAX_DURABILITY = {
    [BLOCKS.WOOD_PICKAXE]: 60, [BLOCKS.WOOD_AXE]: 60, [BLOCKS.WOOD_SWORD]: 40,
    [BLOCKS.STONE_PICKAXE]: 132, [BLOCKS.STONE_AXE]: 132, [BLOCKS.STONE_SWORD]: 100,
    [BLOCKS.IRON_PICKAXE]: 250, [BLOCKS.IRON_AXE]: 250, [BLOCKS.IRON_SHOVEL]: 250, [BLOCKS.IRON_SWORD]: 200, 
    [BLOCKS.SHEARS]: 238, [BLOCKS.SLIME_BOOTS]: 500
};

const QUESTS = [
    { id: 1, text: "Thu thập 5 Gỗ", check: (inv) => inv.some(i => i && i.id === BLOCKS.LOG && i.count >= 5), rewardXP: 100 },
    { id: 2, text: "Chế tạo Bàn Chế Tạo", check: (inv) => inv.some(i => i && i.id === BLOCKS.WORKBENCH), rewardXP: 150 },
    { id: 3, text: "Đào 3 Than để làm đuốc", check: (inv) => inv.some(i => i && i.id === BLOCKS.COAL && i.count >= 3), rewardXP: 200 },
    { id: 4, text: "Chế tạo Lò Nung", check: (inv) => inv.some(i => i && i.id === BLOCKS.FURNACE), rewardXP: 250 },
    { id: 5, text: "Tìm Kim Cương dưới sâu", check: (inv) => inv.some(i => i && i.id === BLOCKS.DIAMOND), rewardXP: 1000 }
];

const GAME_STATE = {
    hp: 100, maxHp: 100, 
    hunger: 100, maxHunger: 100,
    xp: 0, level: 1, nextLevelXp: 100,
    baseDamage: 1, 
    selectedSlot: 0, isMining: false, miningProgress: 0, showCrafting: false,
    nearWorkbench: false, nearFurnace: false, nearAnvil: false, nearCampfire: false,
    inventory: Array(10).fill(null), itemNameTimer: 0,
    lastAttackTime: 0, lastCombatTime: 0, regenTimer: 0, hungerTimer: 0,
    lastEatTime: 0,
    currentQuestIdx: 0,
    isBloodMoon: false,
    spawnPoint: null,
    seed: Math.random() * 1000
};

GAME_STATE.inventory[0] = { id: BLOCKS.WOOD_SWORD, name: 'Kiếm Gỗ', count: 1, durability: 40 };
GAME_STATE.inventory[1] = { id: BLOCKS.APPLE, name: 'Táo', count: 5 }; 
GAME_STATE.inventory[2] = { id: BLOCKS.SLIMEBALL, name: 'Mật Slime', count: 10 }; 

// --- HELPER: GET ITEM ASSET ---
function getItemAsset(id) {
    if (id < 100) return { key: 'maptiles', frame: id };
    const icons = {
        [BLOCKS.WOOD_PICKAXE]: 'icon_wood_pickaxe', [BLOCKS.WOOD_AXE]: 'icon_wood_axe', [BLOCKS.WOOD_SWORD]: 'icon_wood_sword',
        [BLOCKS.STONE_PICKAXE]: 'icon_stone_pickaxe', [BLOCKS.STONE_AXE]: 'icon_stone_axe', [BLOCKS.STONE_SWORD]: 'icon_stone_sword',
        [BLOCKS.IRON_PICKAXE]: 'icon_iron_pickaxe', [BLOCKS.IRON_AXE]: 'icon_iron_axe', [BLOCKS.IRON_SHOVEL]: 'icon_iron_shovel', [BLOCKS.IRON_SWORD]: 'icon_iron_sword',
        [BLOCKS.SHEARS]: 'icon_shears', [BLOCKS.SLIME_BOOTS]: 'icon_slime_boots',
        [BLOCKS.RAW_IRON]: 'icon_raw_iron', [BLOCKS.RAW_GOLD]: 'icon_raw_gold', [BLOCKS.COAL]: 'icon_coal',
        [BLOCKS.IRON_INGOT]: 'icon_iron_ingot', [BLOCKS.GOLD_INGOT]: 'icon_gold_ingot',
        [BLOCKS.SLIMEBALL]: 'icon_slime_ball_ui', [BLOCKS.DIAMOND]: 'icon_diamond', // Changed key to avoid clash
        [BLOCKS.APPLE]: 'icon_apple', [BLOCKS.GOLDEN_APPLE]: 'icon_golden_apple'
    };
    if (id === BLOCKS.BED) return { key: 'icon_bed', frame: undefined };
    if (id === BLOCKS.CAMPFIRE) return { key: 'icon_campfire', frame: undefined };
    if (id === BLOCKS.CHEST) return { key: 'icon_chest', frame: undefined };
    if (icons[id]) return { key: icons[id], frame: undefined };
    return { key: 'marker', frame: undefined };
}

// --- HELPER: GET BIOME ---
function getBiomeAt(x) {
    const section = WORLD_WIDTH / 3;
    const noise = Math.sin((x + GAME_STATE.seed) / 60) + Math.sin((x + GAME_STATE.seed) / 20) * 0.2;
    
    // Main regions mixed with noise
    if (x < section) return 'FOREST';
    if (x >= section && x < section * 2) return 'DESERT';
    if (x >= section * 2) return 'SNOW';
    
    // Fallback based on noise if we wanted mixed biomes, but strict separation is requested
    if (noise < -0.2) return 'MOUNTAIN'; 
    return 'PLAINS';
}

// --- NEW SCENE: MAIN MENU ---
class MenuScene extends Phaser.Scene {
    constructor() { super({ key: 'MenuScene' }); }
    
    create() {
        const w = this.scale.width;
        const h = this.scale.height;

        // Background
        this.add.rectangle(w/2, h/2, w, h, 0x212121);
        
        // Title
        this.add.text(w/2, h/3, "OPEN GEODE", { font: 'bold 48px Courier New', fill: '#00BFFF' }).setOrigin(0.5);
        this.add.text(w/2, h/3 + 40, "Chọn kích thước thế giới:", { font: '20px Courier New', fill: '#FFF' }).setOrigin(0.5);

        // Buttons
        this.createButton(w/2, h/2, "NHỎ (150)", 0x4CAF50, 150);
        this.createButton(w/2, h/2 + 60, "VỪA (300)", 0xFF9800, 300);
        this.createButton(w/2, h/2 + 120, "ĐẠI (600)", 0xF44336, 600);
    }

    createButton(x, y, text, color, width) {
        const bg = this.add.rectangle(x, y, 200, 50, color).setInteractive({ useHandCursor: true });
        const txt = this.add.text(x, y, text, { font: 'bold 20px Courier New', fill: '#FFF' }).setOrigin(0.5);
        
        bg.on('pointerover', () => bg.setAlpha(0.8));
        bg.on('pointerout', () => bg.setAlpha(1));
        bg.on('pointerdown', () => {
            WORLD_WIDTH = width; // Set global config
            this.scene.start('GameScene'); // Start Game
            this.scene.start('UIScene'); // Start UI
        });
    }
}

// --- CLASS ENEMY ---
class Enemy extends Phaser.Physics.Arcade.Sprite {
    constructor(scene, x, y, type) {
        let textureKey = 'slime_idle_tex';
        if (type === 'MUMMY') textureKey = 'mummy_idle_tex';
        if (type === 'YETI') textureKey = 'yeti_idle_tex';
        if (type === 'SKELETON') textureKey = 'skeleton_idle_tex';

        super(scene, x, y, textureKey);
        scene.add.existing(this);
        scene.physics.add.existing(this);
        
        this.setCollideWorldBounds(true);
        this.body.setSize(20, 28); this.body.setOffset(6, 4);
        this.setBounce(0.1); this.setDepth(10);
        
        this.enemyType = type;
        this.jumpTimer = 0;
        this.direction = 1;
        this.isHurt = false;

        if (type === 'SLIME') {
            this.hp = 20; this.damage = 10; this.jumpForce = -500; this.moveSpeed = 100; this.jumpDelay = {min: 1000, max: 3000};
            this.body.setSize(24, 20); this.body.setOffset(4, 12);
        } else if (type === 'MUMMY') {
            this.hp = 40; this.damage = 15; this.jumpForce = -300; this.moveSpeed = 60; this.jumpDelay = {min: 2000, max: 4000};
        } else if (type === 'YETI') {
            this.hp = 60; this.damage = 25; this.jumpForce = -600; this.moveSpeed = 180; this.jumpDelay = {min: 500, max: 2000};
        } else if (type === 'SKELETON') {
            this.hp = 30; this.damage = 20; this.jumpForce = -550; this.moveSpeed = 140; this.jumpDelay = {min: 1000, max: 2500};
        }
    }

    update(time, delta, player) {
        if (this.hp <= 0 || !player) return;

        if (this.body.velocity.y === 0) {
            if (this.enemyType === 'SLIME') this.play('slime_idle', true);
            else if (this.enemyType === 'MUMMY') this.play('mummy_idle', true);
            else if (this.enemyType === 'YETI') this.play('yeti_idle', true);
            else if (this.enemyType === 'SKELETON') this.play('skeleton_idle', true);
        }

        if (this.body.onFloor()) {
            this.setVelocityX(0);
            if (time > this.jumpTimer) {
                const dist = Phaser.Math.Distance.Between(this.x, this.y, player.x, player.y);
                let range = 300;
                if (this.enemyType === 'YETI' || this.enemyType === 'SKELETON') range = 500; 
                if (GAME_STATE.isBloodMoon) range *= 2;

                if (dist < range) { 
                    this.direction = (player.x > this.x) ? 1 : -1;
                } else {
                    this.direction = Math.random() > 0.5 ? 1 : -1;
                }
                this.setVelocityY(this.jumpForce);
                this.setVelocityX(this.moveSpeed * (GAME_STATE.isBloodMoon ? 1.5 : 1) * this.direction);
                this.setFlipX(this.direction < 0);
                this.jumpTimer = time + Phaser.Math.Between(this.jumpDelay.min, this.jumpDelay.max);
            }
        }
    }

    takeDamage(amount, fromX) {
        if (this.isHurt || this.hp <= 0) return;
        this.hp -= amount; this.isHurt = true; this.setTint(0xFF0000);
        const knockDir = (this.x > fromX) ? 1 : -1;
        this.setVelocity(150 * knockDir, -200);

        if (this.hp <= 0) {
            this.scene.gainXP(SURVIVAL_CONFIG.XP_PER_KILL);
            this.scene.tweens.add({
                targets: this, scale: 0, alpha: 0, duration: 300,
                onComplete: () => {
                    let dropId = BLOCKS.SLIMEBALL;
                    if (this.enemyType === 'MUMMY') dropId = BLOCKS.COAL;
                    if (this.enemyType === 'YETI') dropId = BLOCKS.SNOW;
                    if (this.enemyType === 'SKELETON') dropId = BLOCKS.RAW_GOLD; 
                    this.scene.createDrop(this.x, this.y, dropId, 1);
                    this.destroy(); 
                }
            });
        } else {
            this.scene.time.delayedCall(300, () => { this.clearTint(); this.isHurt = false; });
        }
    }
}

class GameScene extends Phaser.Scene {
    constructor() { super({ key: 'GameScene' }); }

    preload() {
        const g = this.make.graphics({ x: 0, y: 0, add: false });
        const drawPixel = (x, y, color) => { g.fillStyle(color, 1); g.fillRect(x*2, y*2, 2, 2); };
        const drawNoise = (x, y, colorBase, colorDark, density) => {
            g.fillStyle(colorBase); g.fillRect(x, y, 32, 32); g.fillStyle(colorDark);
            for(let i=0; i<32; i+=4) { for(let j=0; j<32; j+=4) { if(Math.random() < density) g.fillRect(x+i, y+j, 4, 4); }}
        };

        // Blocks
        drawNoise(0, 0, 0x795548, 0x5D4037, 0.3); // 0
        drawNoise(32, 0, 0x795548, 0x5D4037, 0.3); g.fillStyle(0x558B2F); g.fillRect(32, 0, 32, 8); // 1
        drawNoise(64, 0, 0x9E9E9E, 0x757575, 0.4); // 2
        const drawOre = (ox, color) => { drawNoise(ox, 0, 0x9E9E9E, 0x757575, 0.4); g.fillStyle(color); g.fillRect(ox+8, 8, 4, 4); g.fillRect(ox+12, 8, 4, 4); g.fillRect(ox+8, 12, 4, 4); };
        drawOre(96, 0x212121); drawOre(128, 0xD7CCC8); drawOre(160, 0xFFECB3); 
        drawOre(192, 0x00BFFF); 

        g.fillStyle(0x6D4C41); g.fillRect(224, 0, 32, 32); g.fillStyle(0x3E2723); g.fillRect(224+4, 0, 4, 32); g.fillRect(224+12, 0, 4, 32); g.fillRect(224+24, 0, 4, 32); g.fillRect(224, 0, 32, 2); g.fillRect(224, 30, 32, 2); 
        g.fillStyle(0x2E7D32); g.fillRect(256, 0, 32, 32); g.fillStyle(0x66BB6A); for(let i=0; i<32; i+=4) { for(let j=0; j<32; j+=4) { if(Math.random() < 0.4) g.fillRect(256+i, j, 4, 4); }} 
        g.fillStyle(0x5D4037); g.fillRect(300, 14, 4, 18); g.fillStyle(0xFFEB3B); g.fillRect(298, 10, 8, 4); 
        g.fillStyle(0x8D6E63); g.fillRect(320, 0, 32, 32); g.fillStyle(0x3E2723); g.strokeRect(320, 0, 32, 32); g.fillStyle(0x5D4037); g.fillRect(320+4, 4, 24, 24); 
        g.fillStyle(0x616161); g.fillRect(352, 0, 32, 32); g.fillStyle(0x000000); g.fillRect(352+4, 4, 24, 24); 
        g.fillStyle(0x757575); g.fillRect(384, 0, 32, 32); 
        g.fillStyle(0xA1887F); g.fillRect(416, 0, 32, 32); 
        g.fillStyle(0x424242); g.fillRect(448, 0, 32, 32); 
        g.fillStyle(0x33691E); g.fillRect(480+14, 16, 4, 16); 
        g.fillStyle(0x76FF03); g.fillRect(512, 0, 32, 32); g.fillStyle(0x64DD17); g.fillRect(512+4, 4, 24, 24); 
        drawNoise(544, 0, 0xF6E79D, 0xE6D690, 0.15); 
        g.fillStyle(0x43A047); g.fillRect(576, 0, 32, 32); g.fillStyle(0x1B5E20); g.fillRect(576+4, 0, 4, 32); g.fillRect(576+14, 0, 4, 32); g.fillRect(576+24, 0, 4, 32); g.fillStyle(0x000000); for(let i=0; i<32; i+=8) { g.fillRect(576, i+4, 2, 2); g.fillRect(576+30, i+4, 2, 2); } 
        drawNoise(608, 0, 0xFFFFFF, 0xE3F2FD, 0.1); 
        g.fillStyle(0x8D6E63); g.fillRect(640, 0, 32, 32); g.fillStyle(0x3E2723); g.strokeRect(640, 0, 32, 32); g.fillStyle(0xFFD700); g.fillRect(640+14, 12, 4, 6); 
        g.fillStyle(0x3E2723); g.fillRect(672+4, 24, 24, 8); g.fillStyle(0xFF5722); g.fillRect(672+10, 10, 12, 14); g.fillStyle(0xFFEB3B); g.fillRect(672+12, 12, 8, 10); 
        g.fillStyle(0x8D6E63); g.fillRect(704, 16, 32, 16); g.fillStyle(0xD32F2F); g.fillRect(704, 16, 32, 12); g.fillStyle(0xFFFFFF); g.fillRect(704, 16, 8, 10); 
        g.generateTexture('maptiles', 736, 32);

        // --- ICONS (UI) ---
        const createIcon = (key, callback) => { g.clear(); callback(); g.generateTexture(key, 32, 32); };
        createIcon('icon_coal', () => { g.fillStyle(0x212121); drawPixel(6,5,0x212121); drawPixel(7,5,0x212121); drawPixel(8,5,0x212121); drawPixel(9,5,0x212121); g.fillRect(10, 12, 12, 8); });
        const drawRaw = (key, color) => { g.clear(); g.fillStyle(color); drawPixel(7,5,color); drawPixel(8,5,color); g.fillRect(10, 10, 12, 10); g.generateTexture(key, 32, 32); };
        drawRaw('icon_raw_iron', 0xD7CCC8); drawRaw('icon_raw_gold', 0xFFECB3);
        createIcon('icon_slimeball', () => { drawPixel(7,6,0x33691E); drawPixel(8,6,0x33691E); g.fillStyle(0x76FF03); g.fillRect(10, 12, 12, 6); drawPixel(7,7,0xCCFF90); });
        createIcon('icon_slime_ball_ui', () => { drawPixel(7,6,0x33691E); drawPixel(8,6,0x33691E); g.fillStyle(0x76FF03); g.fillRect(10, 12, 12, 6); drawPixel(7,7,0xCCFF90); }); // Fix name mismatch
        const drawIngot = (key, color) => { g.clear(); g.fillStyle(color); g.fillRect(6, 10, 20, 12); g.fillStyle(0xFFFFFF); g.fillRect(6, 10, 20, 2); g.generateTexture(key, 32, 32); };
        drawIngot('icon_iron_ingot', 0xD7CCC8); drawIngot('icon_gold_ingot', 0xFFECB3);
        createIcon('icon_diamond', () => { g.fillStyle(0x00BFFF); drawPixel(7,5,0x00BFFF); drawPixel(8,5,0x00BFFF); g.fillRect(12, 12, 8, 8); });
        createIcon('icon_apple', () => { g.fillStyle(0xD50000); g.fillRect(12, 12, 8, 8); g.fillStyle(0x2E7D32); drawPixel(7,4,0x2E7D32); });
        createIcon('icon_golden_apple', () => { g.fillStyle(0xFFD700); g.fillRect(12, 12, 8, 8); g.fillStyle(0xFFFFFF); drawPixel(6,6,0xFFFFFF); });
        createIcon('icon_bed', () => { g.fillStyle(0xD32F2F); g.fillRect(4, 10, 24, 12); g.fillStyle(0xFFFFFF); g.fillRect(4, 10, 8, 6); });
        createIcon('icon_campfire', () => { g.fillStyle(0x3E2723); g.fillRect(6, 20, 20, 4); g.fillStyle(0xFF5722); g.fillRect(12, 10, 8, 10); });
        createIcon('icon_chest', () => { g.fillStyle(0x8D6E63); g.fillRect(6, 10, 20, 16); g.fillStyle(0xFFD700); g.fillRect(14, 16, 4, 4); });

        const drawMCTool = (key, headColor, type) => {
            g.clear(); const handleColor = 0x5D4037; g.fillStyle(handleColor);
            if (type === 'SWORD') { drawPixel(7, 13, handleColor); drawPixel(7, 14, handleColor); drawPixel(8, 15, handleColor); } else { drawPixel(2, 13, handleColor); drawPixel(3, 12, handleColor); drawPixel(4, 11, handleColor); drawPixel(5, 10, handleColor); drawPixel(6, 9, handleColor); drawPixel(7, 8, handleColor); }
            g.fillStyle(headColor);
            if(type==='PICK') { drawPixel(7,5,headColor); drawPixel(8,4,headColor); drawPixel(9,3,headColor); drawPixel(10,2,headColor); drawPixel(11,2,headColor); drawPixel(12,3,headColor); drawPixel(13,4,headColor); drawPixel(6,6,headColor); drawPixel(13,5,headColor); drawPixel(5,7,headColor); drawPixel(12,6,headColor); drawPixel(4,8,headColor); drawPixel(11,7,headColor); }
            if(type==='AXE') { drawPixel(7,5,headColor); drawPixel(8,4,headColor); drawPixel(9,4,headColor); drawPixel(7,6,headColor); drawPixel(8,5,headColor); drawPixel(9,5,headColor); drawPixel(10,5,headColor); drawPixel(6,7,headColor); drawPixel(7,7,headColor); drawPixel(8,6,headColor); drawPixel(9,6,headColor); drawPixel(6,8,headColor); drawPixel(7,8,headColor); drawPixel(8,7,headColor); drawPixel(6,9,headColor); drawPixel(7,9,headColor); }
            if(type==='SWORD') { drawPixel(5,11,headColor); drawPixel(6,12,headColor); drawPixel(8,12,headColor); drawPixel(9,11,headColor); drawPixel(6,11,headColor); drawPixel(7,11,headColor); drawPixel(8,11,headColor); for(let i=2; i<=10; i++) { drawPixel(7, i, headColor); drawPixel(8, i, headColor); } drawPixel(7,1,headColor); drawPixel(8,1,headColor); }
            if(type==='SHOVEL') { drawPixel(8,4,headColor); drawPixel(9,5,headColor); drawPixel(10,6,headColor); drawPixel(7,5,headColor); drawPixel(8,5,headColor); drawPixel(9,6,headColor); drawPixel(6,6,headColor); drawPixel(7,6,headColor); drawPixel(8,6,headColor); drawPixel(9,7,headColor); drawPixel(7,7,headColor); drawPixel(8,7,headColor); }
            if(type==='BOOTS') { drawPixel(5, 12, headColor); drawPixel(6, 12, headColor); drawPixel(5, 13, headColor); drawPixel(6, 13, headColor); drawPixel(7, 13, headColor); drawPixel(10, 12, headColor); drawPixel(11, 12, headColor); drawPixel(10, 13, headColor); drawPixel(11, 13, headColor); drawPixel(9, 13, headColor); }
            g.generateTexture(key, 32, 32);
        };
        drawMCTool('icon_wood_pickaxe', 0xA1887F, 'PICK'); drawMCTool('icon_wood_axe', 0xA1887F, 'AXE'); drawMCTool('icon_wood_sword', 0xA1887F, 'SWORD');
        drawMCTool('icon_stone_pickaxe', 0x9E9E9E, 'PICK'); drawMCTool('icon_stone_axe', 0x9E9E9E, 'AXE'); drawMCTool('icon_stone_sword', 0x9E9E9E, 'SWORD');
        drawMCTool('icon_iron_pickaxe', 0xFFFFFF, 'PICK'); drawMCTool('icon_iron_axe', 0xFFFFFF, 'AXE'); drawMCTool('icon_iron_shovel', 0xFFFFFF, 'SHOVEL'); drawMCTool('icon_iron_sword', 0xFFFFFF, 'SWORD');
        drawMCTool('icon_slime_boots', 0x76FF03, 'BOOTS');

        g.clear(); g.fillStyle(0xFFFFFF); g.fillRect(4,4,24,24); g.fillStyle(0x000000); g.fillRect(14,14,4,4); g.generateTexture('icon_shears', 32, 32);

        // Mobs
        g.clear(); drawPixel(4,4,0x4CAF50); drawPixel(11,4,0x4CAF50); g.fillStyle(0x81C784); g.fillRect(4, 10, 24, 20); g.fillStyle(0x2E7D32); g.fillRect(8, 14, 16, 12); drawPixel(4,9,0x1B5E20); drawPixel(11,9,0x1B5E20); drawPixel(7,11,0x1B5E20); drawPixel(8,11,0x1B5E20); g.generateTexture('slime_idle_tex', 32, 32);
        g.clear(); g.fillStyle(0x81C784); g.fillRect(2, 14, 28, 16); g.fillStyle(0x2E7D32); g.fillRect(6, 18, 20, 8); drawPixel(4,9,0x1B5E20); drawPixel(11,9,0x1B5E20); g.generateTexture('slime_jump_tex', 32, 32);
        g.clear(); g.fillStyle(0xE0E0E0); g.fillRect(8, 0, 16, 16); drawPixel(5,2,0x212121); drawPixel(9,2,0x212121); drawPixel(5,2,0xD50000); drawPixel(9,2,0xD50000); g.fillStyle(0xF5F5F5); g.fillRect(8, 16, 16, 24); g.fillStyle(0xBDBDBD); g.fillRect(8, 18, 16, 2); g.fillRect(8, 22, 16, 2); g.fillRect(8, 26, 16, 2); g.fillStyle(0xE0E0E0); g.fillRect(4, 16, 4, 20); g.fillRect(24, 16, 4, 20); g.generateTexture('mummy_idle_tex', 32, 40); 
        g.clear(); g.fillStyle(0xF5F5F5); g.fillRect(4, 4, 24, 28); g.fillStyle(0xB3E5FC); g.fillRect(10, 8, 12, 10); drawPixel(6,5,0x000000); drawPixel(9,5,0x000000); drawPixel(6,8,0xFFFFFF); drawPixel(9,8,0xFFFFFF); g.generateTexture('yeti_idle_tex', 32, 32);
        g.clear(); g.fillStyle(0xE0E0E0); g.fillRect(8,0,16,16); drawPixel(5,4,0x212121); drawPixel(9,4,0x212121); g.fillRect(14,16,4,12); g.fillRect(8,18,16,4); g.fillRect(10,28,4,12); g.fillRect(18,28,4,12); g.fillRect(4,18,4,12); g.fillRect(24,18,4,12); g.generateTexture('skeleton_idle_tex', 32, 40);
        g.clear(); const drawSteve = (ox, f) => { g.fillStyle(0xFBC02D); g.fillRect(ox+8, 0, 16, 16); g.fillStyle(0x5D4037); g.fillRect(ox+8, 0, 16, 4); drawPixel(4,2,0x5D4037); drawPixel(11,2,0x5D4037); drawPixel(5,4,0xFFFFFF); drawPixel(9,4,0xFFFFFF); drawPixel(6,4,0x304FFE); drawPixel(10,4,0x304FFE); drawPixel(7,6,0x8D6E63); drawPixel(8,6,0x8D6E63); g.fillStyle(0x0288D1); g.fillRect(ox+8, 16, 16, 12); drawPixel(2,8, 0x0288D1); drawPixel(3,8, 0x0288D1); drawPixel(12,8, 0x0288D1); drawPixel(13,8, 0x0288D1); g.fillStyle(0xFBC02D); g.fillRect(ox+4, 20, 4, 8); g.fillRect(ox+24, 20, 4, 8); g.fillStyle(0x303F9F); if(f==0) { g.fillRect(ox+8, 28, 6, 4); g.fillRect(ox+18, 28, 6, 4); } if(f==1) { g.fillRect(ox+6, 28, 6, 4); g.fillRect(ox+20, 28, 6, 4); } g.fillStyle(0x616161); if(f==0) { g.fillRect(ox+8, 32, 6, 2); g.fillRect(ox+18, 32, 6, 2); } if(f==1) { g.fillRect(ox+6, 32, 6, 2); g.fillRect(ox+20, 32, 6, 2); } }; drawSteve(0,0); drawSteve(32,1); g.generateTexture('player_anim', 64, 34); 

        g.clear(); g.lineStyle(3, 0x00FFFF, 0.8); g.strokeRect(0,0,32,32); g.generateTexture('marker', 32, 32);
        g.clear(); g.fillStyle(0xFF0000); g.fillCircle(5,5,5); g.fillCircle(11,5,5); g.fillTriangle(0,5,16,5,8,15); g.generateTexture('heart', 16, 16);
        g.clear(); g.fillStyle(0xFFFFFF, 0.8); g.fillRect(10, 10, 60, 20); g.fillRect(30, 0, 50, 20); g.fillRect(50, 20, 40, 10); g.generateTexture('cloud', 100, 40);
        
        const canvas = this.textures.createCanvas('light_mask', 256, 256);
        const ctx = canvas.context;
        const grd = ctx.createRadialGradient(128, 128, 0, 128, 128, 128);
        grd.addColorStop(0, 'rgba(255, 255, 220, 1)'); grd.addColorStop(0.5, 'rgba(255, 220, 150, 0.5)'); grd.addColorStop(1, 'rgba(0, 0, 0, 0)'); 
        ctx.fillStyle = grd; ctx.fillRect(0, 0, 256, 256); canvas.refresh();

        g.clear(); g.fillStyle(0x64B5F6, 0.8); g.fillRect(0, 0, 2, 8); g.generateTexture('rain_drop', 2, 8);
        g.clear(); g.fillStyle(0xFFFFFF, 0.9); g.fillRect(0, 0, 4, 4); g.generateTexture('snow_flake', 4, 4);
    }

    create() {
        const mapTex = this.textures.get('maptiles'); for (let i = 0; i <= 22; i++) mapTex.add(i, 0, i * 32, 0, 32, 32); 
        const pTex = this.textures.get('player_anim'); pTex.add('idle', 0, 0, 0, 32, 34); pTex.add('run1', 0, 32, 0, 32, 34); 
        this.anims.create({ key: 'idle', frames: [ { key: 'player_anim', frame: 'idle' } ], frameRate: 10 });
        this.anims.create({ key: 'run', frames: [ { key: 'player_anim', frame: 'run1' }, { key: 'player_anim', frame: 'run2' } ], frameRate: 8, repeat: -1 });

        this.anims.create({ key: 'slime_idle', frames: [{ key: 'slime_idle_tex' }], frameRate: 1 });
        this.anims.create({ key: 'slime_jump', frames: [{ key: 'slime_jump_tex' }], frameRate: 1 });
        this.anims.create({ key: 'mummy_idle', frames: [{ key: 'mummy_idle_tex' }], frameRate: 1 });
        this.anims.create({ key: 'yeti_idle', frames: [{ key: 'yeti_idle_tex' }], frameRate: 1 });
        this.anims.create({ key: 'skeleton_idle', frames: [{ key: 'skeleton_idle_tex' }], frameRate: 1 });

        this.skyLayer = this.add.rectangle(0, 0, 20000, 20000, 0x87CEEB).setDepth(-10).setScrollFactor(0);
        this.clouds = this.add.group();
        for(let i=0; i<15; i++) {
            const c = this.add.image(Phaser.Math.Between(0, WORLD_WIDTH*32), Phaser.Math.Between(0, 300), 'cloud');
            c.setDepth(-5); c.setAlpha(0.8); c.setScale(Phaser.Math.FloatBetween(0.5, 1.5));
            c.speed = Phaser.Math.FloatBetween(0.2, 0.5); this.clouds.add(c);
        }

        this.map = this.make.tilemap({ tileWidth: TILE_SIZE, tileHeight: TILE_SIZE, width: WORLD_WIDTH, height: WORLD_HEIGHT });
        const tileset = this.map.addTilesetImage('maptiles', 'maptiles', 32, 32);
        this.groundLayer = this.map.createBlankLayer('Ground', tileset).setDepth(0);
        this.objectLayer = this.map.createBlankLayer('Objects', tileset).setDepth(5);

        const offsetA = Math.random() * 1000;
        const offsetB = Math.random() * 1000;

        for (let x = 0; x < WORLD_WIDTH; x++) {
            const biome = getBiomeAt(x);
            let y1 = 0;

            if (biome === 'MOUNTAIN') y1 = Math.sin((x + offsetA) / 10) * 15; 
            else if (biome === 'PLAINS') y1 = Math.sin((x + offsetA) / 30) * 2; 
            else if (biome === 'DESERT') y1 = Math.sin((x + offsetA) / 15) * 5; 
            else y1 = Math.sin((x + offsetA) / 25) * 8; 

            let surface = Math.floor((WORLD_HEIGHT / 2) + y1);

            for (let y = 0; y < WORLD_HEIGHT; y++) {
                if (y === surface) {
                    if (biome === 'DESERT') this.groundLayer.putTileAt(BLOCKS.SAND, x, y);
                    else if (biome === 'SNOW') this.groundLayer.putTileAt(BLOCKS.SNOW, x, y);
                    else if (biome === 'MOUNTAIN') this.groundLayer.putTileAt(BLOCKS.STONE, x, y);
                    else this.groundLayer.putTileAt(BLOCKS.GRASS, x, y);
                } else if (y > surface && y < surface + 5) {
                    if (biome === 'DESERT') this.groundLayer.putTileAt(BLOCKS.SAND, x, y);
                    else this.groundLayer.putTileAt(BLOCKS.DIRT, x, y);
                } else if (y >= surface + 5) {
                    if (y > WORLD_HEIGHT - 10 && Math.random() < 0.01) this.groundLayer.putTileAt(BLOCKS.DIAMOND_ORE, x, y);
                    else this.groundLayer.putTileAt(BLOCKS.STONE, x, y);
                }
            }
            
            if (x > 5 && x < WORLD_WIDTH - 5) {
                if (biome === 'FOREST' && Math.random() < 0.1) this.generateTree(x, surface - 1);
                if (biome === 'DESERT' && Math.random() < 0.05) this.generateCactus(x, surface - 1);
                if (biome === 'SNOW' && Math.random() < 0.08) this.generatePineTree(x, surface - 1);
                if (biome === 'MOUNTAIN' && Math.random() < 0.02) this.objectLayer.putTileAt(BLOCKS.CHEST, x, surface - 1);
            }
        }

        const ORES = [{id:BLOCKS.COAL_ORE, chance:0.015, size:2.5, sY:0.15}, {id:BLOCKS.IRON_ORE, chance:0.008, size:2.0, sY:0.40}, {id:BLOCKS.GOLD_ORE, chance:0.005, size:1.8, sY:0.75}];
        ORES.forEach(ore => { for(let x=0; x<WORLD_WIDTH; x++) { for(let y=Math.floor(WORLD_HEIGHT*ore.sY); y<WORLD_HEIGHT; y++) { if(Math.random()<ore.chance) this.generateVein(x,y,ore.id,ore.size); }}});
        
        this.groundLayer.setCollisionByExclusion([-1]);
        this.objectLayer.setCollision([BLOCKS.SLIME_BLOCK, BLOCKS.CACTUS]); 
        this.physics.world.setBounds(0, 0, this.map.widthInPixels, this.map.heightInPixels);

        this.drops = this.physics.add.group({ bounceY: 0.2, dragX: 1000 }); 
        this.physics.add.collider(this.drops, this.groundLayer);

        this.enemies = this.physics.add.group({ classType: Enemy, runChildUpdate: false }); 
        this.physics.add.collider(this.enemies, this.groundLayer);

        this.player = this.physics.add.sprite(0, 0, 'player_anim').play('idle');
        this.player.setCollideWorldBounds(true);
        this.player.body.setSize(14, 28); this.player.body.setOffset(9, 4);
        this.player.setDepth(10);
        this.physics.add.collider(this.player, this.groundLayer);
        this.physics.add.collider(this.player, this.objectLayer, (p, t) => {
            if(t.index === BLOCKS.CACTUS) this.takeDamage(1); 
        }); 
        
        this.handItem = this.add.sprite(0, 0, 'maptiles', 0).setDepth(11).setVisible(false).setOrigin(0.5, 0.5);
        this.handItem.setScale(0.6); 

        this.rainParticles = this.add.particles(0, 0, 'rain_drop', { x: 0, y: 0, speedY: { min: 300, max: 500 }, lifespan: 1000, quantity: 0, frequency: 50, scale: { start: 1, end: 1 }, alpha: 0.7, emitting: false });
        this.snowParticles = this.add.particles(0, 0, 'snow_flake', { x: 0, y: 0, speedY: { min: 50, max: 100 }, speedX: { min: -20, max: 20 }, lifespan: 2000, quantity: 0, frequency: 100, scale: { start: 0.5, end: 1 }, alpha: 0.8, emitting: false });
        this.rainParticles.setScrollFactor(0); this.snowParticles.setScrollFactor(0);

        this.physics.add.overlap(this.player, this.drops, (player, drop) => {
            if (drop.getData('pickedUp')) return; 
            if (this.time.now < drop.getData('dropTime')) return;
            if (GAME_STATE.hp > 0 && this.canPickUp(drop.getData('id'))) {
                drop.setData('pickedUp', true); 
                this.tweens.add({ targets: drop, x: player.x, y: player.y, scale: 0.1, duration: 100, onComplete: () => { 
                    this.addToInventory(drop.getData('id'), drop.getData('durability')); 
                    drop.destroy(); 
                }});
            }
        });

        this.physics.add.overlap(this.player, this.enemies, (player, enemy) => {
            if (GAME_STATE.hp > 0 && enemy.hp > 0 && !enemy.isHurt) {
                const now = this.time.now;
                if (now - GAME_STATE.lastAttackTime > 1000) { 
                    this.takeDamage(enemy.damage); 
                    const knockDir = (player.x < enemy.x) ? -1 : 1;
                    player.setVelocity(knockDir * 300, -200);
                    GAME_STATE.lastAttackTime = now;
                }
            }
        });

        this.respawnPlayer();
        this.cameras.main.setBounds(0, 0, this.map.widthInPixels, this.map.heightInPixels);
        this.cameras.main.startFollow(this.player, true, 0.1, 0.1);
        this.cameras.main.setZoom(1.5);
        
        this.darkness = this.make.renderTexture({ width: this.scale.width, height: this.scale.height }, false);
        this.darkness.setDepth(20); this.darkness.setScrollFactor(0); 

        // Start Menu is active, so we don't start spawning immediately until GameScene is properly active
        // But for simplicity, the menu scene handles the start.
    }
    // ... (Spawn/Gen functions same as v25.4) ...
    trySpawnEnemy() { if (this.enemies.countActive() >= SPAWN_CONFIG.MAX_ENEMIES) return; for(let i=0; i<5; i++) { const spawnX = Phaser.Math.Between(5, WORLD_WIDTH - 5); const biome = getBiomeAt(spawnX); for (let y = 0; y < WORLD_HEIGHT - 1; y++) { const tile = this.groundLayer.getTileAt(spawnX, y); if (tile && tile.index !== -1) { const tileAbove = this.groundLayer.getTileAt(spawnX, y - 1); if (!tileAbove || tileAbove.index === -1) { const pixelX = spawnX * 32; const pixelY = (y - 1) * 32; const dist = Phaser.Math.Distance.Between(pixelX, pixelY, this.player.x, this.player.y); if (dist > SPAWN_CONFIG.MIN_DIST) { let type = 'SLIME'; if (GAME_STATE.isBloodMoon) { if (Math.random() < 0.5) type = 'SKELETON'; } else { if (biome === 'DESERT') type = 'MUMMY'; else if (biome === 'SNOW') type = 'YETI'; else if (this.time.now % 24000 > 12000) type = 'SKELETON'; } this.enemies.add(new Enemy(this, pixelX, pixelY, type)); return; } } break; } } } }
    createDrop(x, y, id, count) { let data = getItemAsset(id); for(let i=0; i<count; i++) { const drop = this.drops.create(x + Phaser.Math.Between(-10,10), y - 10, data.key, data.frame); drop.setDisplaySize(16, 16); drop.setVelocity(Phaser.Math.Between(-50,50), -150); drop.setData('id', id); drop.setData('durability', undefined); drop.setData('dropTime', this.time.now + 500); } }
    generateVein(cx, cy, id, size) { const sx=Math.floor(cx-size), ex=Math.ceil(cx+size), sy=Math.floor(cy-size), ey=Math.ceil(cy+size); for(let x=sx; x<=ex; x++) { for(let y=sy; y<=ey; y++) { if(x<0||x>=WORLD_WIDTH||y<0||y>=WORLD_HEIGHT) continue; if(Phaser.Math.Distance.Between(x,y,cx,cy) <= size && Math.random()>0.2) { if(this.groundLayer.getTileAt(x,y)?.index === BLOCKS.STONE) this.groundLayer.putTileAt(id,x,y); } } } }
    generateTree(x, y) { const height = Phaser.Math.Between(3, 5); for (let i = 0; i < height; i++) this.objectLayer.putTileAt(BLOCKS.LOG, x, y - i); const top = y - height; for (let lx = x - 2; lx <= x + 2; lx++) { for (let ly = top - 2; ly <= top + 1; ly++) { if (lx === x && ly > top) continue; if (Math.abs(lx-x)===2 && Math.abs(ly-top)===2) continue; this.objectLayer.putTileAt(BLOCKS.LEAVES, lx, ly); } } }
    generateCactus(x, y) { const height = Phaser.Math.Between(2, 3); for (let i = 0; i < height; i++) this.objectLayer.putTileAt(BLOCKS.CACTUS, x, y - i); }
    generatePineTree(x, y) { const height = Phaser.Math.Between(4, 6); for (let i = 0; i < height; i++) this.objectLayer.putTileAt(BLOCKS.LOG, x, y - i); const top = y - height; this.objectLayer.putTileAt(BLOCKS.LEAVES, x, top); for(let lx = x-1; lx <= x+1; lx++) this.objectLayer.putTileAt(BLOCKS.LEAVES, lx, top+1); for(let lx = x-2; lx <= x+2; lx++) this.objectLayer.putTileAt(BLOCKS.LEAVES, lx, top+2); if(height > 5) for(let lx = x-2; lx <= x+2; lx++) this.objectLayer.putTileAt(BLOCKS.LEAVES, lx, top+3); }
    showDamageText(x, y, damage, isCrit) { const text = this.add.text(x, y - 20, damage.toString(), { font: isCrit ? 'bold 20px Courier New' : '14px Courier New', fill: isCrit ? '#FF0000' : '#FFFFFF', stroke: '#000000', strokeThickness: 2 }).setOrigin(0.5); this.tweens.add({ targets: text, y: y - 50, alpha: 0, duration: 800, onComplete: () => text.destroy() }); }
    gainXP(amount) { GAME_STATE.xp += amount; if (GAME_STATE.xp >= GAME_STATE.nextLevelXp) { GAME_STATE.level++; GAME_STATE.xp -= GAME_STATE.nextLevelXp; GAME_STATE.nextLevelXp = Math.floor(GAME_STATE.nextLevelXp * 1.5); GAME_STATE.maxHp += 10; GAME_STATE.hp = GAME_STATE.maxHp; GAME_STATE.baseDamage += 1; const txt = this.add.text(this.player.x, this.player.y - 40, 'LEVEL UP!', { font: 'bold 24px Courier New', fill: '#FFFF00', stroke: '#000', strokeThickness: 4 }).setOrigin(0.5); this.tweens.add({ targets: txt, y: this.player.y - 100, alpha: 0, duration: 2000, onComplete: () => txt.destroy() }); this.cameras.main.flash(200, 255, 255, 0); } }

    update(time, delta) {
        if (GAME_STATE.hp <= 0) return; 

        // Day/Night & Blood Moon
        const dayDuration = 120000;
        const timeOfDay = (time % dayDuration) / dayDuration;
        let alpha = 0; let bgColor = 0x87CEEB;
        
        if (timeOfDay > 0.9 && !GAME_STATE.isBloodMoon && Math.random() < 0.005) {
             GAME_STATE.isBloodMoon = true;
             this.cameras.main.shake(500, 0.01);
             this.add.text(this.player.x, this.player.y - 100, "THE BLOOD MOON IS RISING...", { font: 'bold 24px Courier New', fill: '#FF0000' }).setOrigin(0.5).setDepth(100).destroyAfter(3000);
        }
        if (timeOfDay < 0.2) GAME_STATE.isBloodMoon = false;

        if (GAME_STATE.isBloodMoon) bgColor = 0x880000; 
        else if (timeOfDay > 0.9 || timeOfDay < 0.2) bgColor = 0x000022; 

        if (timeOfDay > 0.4 && timeOfDay < 0.9) alpha = (timeOfDay - 0.4) * 2; 
        else if (timeOfDay >= 0.9 || timeOfDay < 0.2) alpha = 0.95; 
        
        this.skyLayer.setFillStyle(bgColor);
        this.darkness.clear(); this.darkness.fill(0x000000, alpha);
        
        if (alpha > 0.1) {
            const cam = this.cameras.main;
            const pX = this.player.x - cam.scrollX; const pY = this.player.y - cam.scrollY;
            this.darkness.erase('light_mask', pX - 128, pY - 128); 
            const startX = Math.floor(cam.scrollX / 32); const endX = startX + Math.ceil(cam.width / 32) + 2;
            const startY = Math.floor(cam.scrollY / 32); const endY = startY + Math.ceil(cam.height / 32) + 2;
            for(let x = startX; x < endX; x++) { for(let y = startY; y < endY; y++) { const tile = this.objectLayer.getTileAt(x, y); if (tile && (tile.index === BLOCKS.TORCH || tile.index === BLOCKS.CAMPFIRE)) { this.darkness.erase('light_mask', (x*32) - cam.scrollX - 112, (y*32) - cam.scrollY - 112); } } }
        }
        this.clouds.children.iterate(c => { c.x += c.speed; if(c.x > WORLD_WIDTH * 32) c.x = 0; });
        
        const pTileX = Math.floor(this.player.x / 32);
        const biome = getBiomeAt(pTileX);

        if (biome === 'FOREST') { 
            this.rainParticles.emitting = true; this.snowParticles.emitting = false; 
            this.rainParticles.setPosition(this.player.x - 400, 0); 
            this.rainParticles.setEmitZone({source: new Phaser.Geom.Rectangle(0,0,800,1)});
        } else if (biome === 'SNOW') { 
            this.snowParticles.emitting = true; this.rainParticles.emitting = false; 
            this.snowParticles.setPosition(this.player.x - 400, 0); 
            this.snowParticles.setEmitZone({source: new Phaser.Geom.Rectangle(0,0,800,1)}); 
        } else { 
            this.rainParticles.emitting = false; this.snowParticles.emitting = false; 
        }

        const now = this.time.now;
        if (now > GAME_STATE.hungerTimer) {
            GAME_STATE.hunger = Math.max(0, GAME_STATE.hunger - 1);
            GAME_STATE.hungerTimer = now + SURVIVAL_CONFIG.HUNGER_DECAY_RATE;
            if (GAME_STATE.hunger === 0) this.takeDamage(SURVIVAL_CONFIG.STARVATION_DAMAGE);
        }

        const pTileY = Math.floor(this.player.y / 32);
        const nearCampfire = this.objectLayer.getTilesWithin(pTileX-2, pTileY-2, 4, 4).some(t => t.index === BLOCKS.CAMPFIRE);
        
        if ((nearCampfire || (now - GAME_STATE.lastCombatTime > REGEN_CONFIG.DELAY)) && GAME_STATE.hp < GAME_STATE.maxHp && GAME_STATE.hunger > 0) {
            if (now > GAME_STATE.regenTimer) {
                GAME_STATE.hp = Math.min(GAME_STATE.maxHp, GAME_STATE.hp + REGEN_CONFIG.AMOUNT);
                GAME_STATE.regenTimer = now + REGEN_CONFIG.RATE;
            }
        }

        const quest = QUESTS[GAME_STATE.currentQuestIdx];
        // ... (UI Update handled in UIScene) ...

        this.enemies.children.iterate(enemy => { if(enemy && enemy.active) enemy.update(time, delta, this.player); });

        this.player.setVelocityX(0);
        let speed = this.keys.SHIFT.isDown ? PHYSICS_CONFIG.RUN_SPEED : PHYSICS_CONFIG.WALK_SPEED;
        let isMoving = false;
        if (this.keys.A.isDown) { this.player.setVelocityX(-speed); this.player.setFlipX(true); isMoving = true; }
        else if (this.keys.D.isDown) { this.player.setVelocityX(speed); this.player.setFlipX(false); isMoving = true; }
        
        let jumpForce = PHYSICS_CONFIG.JUMP_FORCE;
        const hasSlimeBoots = GAME_STATE.inventory.some(i => i && i.id === BLOCKS.SLIME_BOOTS);
        if (hasSlimeBoots) jumpForce = PHYSICS_CONFIG.BOOST_JUMP;

        if (this.player.body.onFloor()) {
            const tileBelow = this.objectLayer.getTileAt(pTileX, pTileY+1);
            if (tileBelow && tileBelow.index === BLOCKS.SLIME_BLOCK) this.player.setVelocityY(PHYSICS_CONFIG.SLIME_BOUNCE);
            else if (this.keys.W.isDown) this.player.setVelocityY(jumpForce);
        }

        if (isMoving && this.player.body.onFloor()) { this.player.anims.play('run', true); this.player.anims.msPerFrame = this.keys.SHIFT.isDown ? 80 : 150; } 
        else this.player.anims.play('idle', true);

        this.updateHandItem();

        if (this.player.body.onFloor() && this.prevVelocityY > PHYSICS_CONFIG.FALL_SAFE_VELOCITY) {
            const damage = Math.floor((this.prevVelocityY - PHYSICS_CONFIG.FALL_SAFE_VELOCITY) * 0.2); 
            const finalDmg = hasSlimeBoots ? Math.floor(damage * 0.5) : damage;
            if (finalDmg > 0) this.takeDamage(finalDmg);
        }
        this.prevVelocityY = this.player.body.velocity.y;

        if (Phaser.Input.Keyboard.JustDown(this.keys.R)) this.respawnPlayer();
        for(let i=0; i<9; i++) { if(this.keys[['ONE','TWO','THREE','FOUR','FIVE','SIX','SEVEN','EIGHT','NINE'][i]].isDown) GAME_STATE.selectedSlot = i; }
        if(this.keys.ZERO.isDown) GAME_STATE.selectedSlot = 9;

        const nearby = this.objectLayer.getTilesWithin(pTileX-2, pTileY-2, 4, 4, {isNotEmpty: true});
        GAME_STATE.nearWorkbench = nearby.some(t => t.index === BLOCKS.WORKBENCH);
        GAME_STATE.nearFurnace = nearby.some(t => t.index === BLOCKS.FURNACE);
        GAME_STATE.nearAnvil = nearby.some(t => t.index === BLOCKS.ANVIL);

        if (Phaser.Input.Keyboard.JustDown(this.keys.E)) GAME_STATE.showCrafting = !GAME_STATE.showCrafting;
        if (Phaser.Input.Keyboard.JustDown(this.keys.Q)) this.dropCurrentItem();

        this.handleInteraction(delta);
    }

    updateHandItem() {
        const item = GAME_STATE.inventory[GAME_STATE.selectedSlot];
        if (item) {
            this.handItem.setVisible(true);
            const data = getItemAsset(item.id);
            this.handItem.setTexture(data.key, data.frame);
            const offsetX = this.player.flipX ? -12 : 12; const offsetY = 6;
            this.handItem.setPosition(this.player.x + offsetX, this.player.y + offsetY);
            this.handItem.setFlipX(this.player.flipX); this.handItem.setRotation(this.player.flipX ? -0.5 : 0.5);
        } else { this.handItem.setVisible(false); }
    }

    swingHand() {
        if (!this.handItem.visible) return;
        const baseRot = this.player.flipX ? -0.5 : 0.5;
        this.tweens.add({ targets: this.handItem, angle: this.player.flipX ? -90 : 90, duration: 100, yoyo: true, onComplete: () => { this.handItem.setRotation(baseRot); } });
    }

    tryDropSapling(x, y) { 
        if (Math.random() < 0.15) this.createDrop(x*32+16, y*32+16, BLOCKS.SAPLING, 1); 
        if (Math.random() < 0.1) this.createDrop(x*32+16, y*32+16, BLOCKS.APPLE, 1);
    }

    takeDamage(amount) {
        GAME_STATE.hp -= amount; if (GAME_STATE.hp < 0) GAME_STATE.hp = 0;
        GAME_STATE.lastCombatTime = this.time.now; 
        this.cameras.main.shake(200, 0.01); this.cameras.main.flash(100, 255, 0, 0); if (GAME_STATE.hp <= 0) this.die();
    }

    die() {
        this.player.setTint(0xff0000); this.player.setVelocity(0, -300); this.player.setCollidesWith([]);
        this.time.delayedCall(2000, () => { 
            this.player.clearTint(); this.player.setCollidesWith(this.groundLayer); 
            if (GAME_STATE.spawnPoint) {
                this.player.setPosition(GAME_STATE.spawnPoint.x, GAME_STATE.spawnPoint.y);
            } else {
                this.respawnPlayer(); 
            }
            GAME_STATE.hunger = 100; GAME_STATE.xp = 0; 
        });
    }

    dropCurrentItem() {
        const slotIdx = GAME_STATE.selectedSlot; const item = GAME_STATE.inventory[slotIdx]; if (!item) return;
        const data = getItemAsset(item.id);
        const drop = this.drops.create(this.player.x, this.player.y - 10, data.key, data.frame);
        drop.setDisplaySize(16, 16); drop.setData('id', item.id); drop.setData('durability', item.durability);
        drop.setData('dropTime', this.time.now + 2000);
        const direction = this.player.flipX ? -1 : 1; const throwX = 200 * direction; const throwY = -250; 
        drop.setVelocity(throwX, throwY); this.tweens.add({ targets: drop, angle: 360, duration: 500, repeat: -1 });
        item.count--; if (item.count <= 0) GAME_STATE.inventory[slotIdx] = null;
    }

    // --- REVISED INTERACTION LOGIC ---
    handleInteraction(delta) {
        if (GAME_STATE.showCrafting || GAME_STATE.hp <= 0) return;
        const ptr = this.input.activePointer; const worldPt = ptr.positionToCamera(this.cameras.main);
        const tX = this.map.worldToTileX(worldPt.x); const tY = this.map.worldToTileY(worldPt.y);

        this.marker.setPosition(tX * TILE_SIZE, tY * TILE_SIZE);
        const dist = Phaser.Math.Distance.Between(this.player.x, this.player.y, worldPt.x, worldPt.y);
        const inRange = dist < 160; this.marker.setAlpha(inRange ? 1 : 0.3);

        if (!ptr.leftButtonDown()) { 
            GAME_STATE.isMining = false; 
            GAME_STATE.miningProgress = 0; 
            this.wasClicking = false; 
        }
        
        const currentItem = GAME_STATE.inventory[GAME_STATE.selectedSlot];
        const isClicking = ptr.leftButtonDown();
        const justClicked = isClicking && !this.wasClicking; 

        if (isClicking && inRange) {
            let attacked = false;
            if (justClicked) {
                this.enemies.children.iterate(enemy => {
                    if (enemy && enemy.active && enemy.getBounds().contains(worldPt.x, worldPt.y)) {
                        this.swingHand(); 
                        let dmg = 2 + (GAME_STATE.baseDamage - 1); 
                        if (currentItem) {
                            if (currentItem.id === BLOCKS.WOOD_SWORD) dmg += 5; if (currentItem.id === BLOCKS.STONE_SWORD) dmg += 7; if (currentItem.id === BLOCKS.IRON_SWORD) dmg += 10;
                        }
                        const isCrit = Math.random() < 0.2; const finalDmg = isCrit ? dmg * 2 : dmg;
                        enemy.takeDamage(finalDmg, this.player.x);
                        this.showDamageText(enemy.x, enemy.y, finalDmg, isCrit);
                        GAME_STATE.lastCombatTime = this.time.now; 
                        if (currentItem && currentItem.durability) { currentItem.durability--; if (currentItem.durability <= 0) GAME_STATE.inventory[GAME_STATE.selectedSlot] = null; }
                        attacked = true;
                    }
                });
            }

            if (attacked) {
                this.wasClicking = true;
                return; 
            }

            let tile = this.objectLayer.getTileAt(tX, tY) || this.groundLayer.getTileAt(tX, tY);
            let targetLayer = this.objectLayer.getTileAt(tX, tY) ? this.objectLayer : this.groundLayer;

            if (tile) {
                if (GAME_STATE.miningProgress === 0) this.swingHand(); 
                if (GAME_STATE.miningProgress >= 1000) this.gainXP(SURVIVAL_CONFIG.XP_PER_ORE);

                let speed = 1;
                if (currentItem) {
                    const id = currentItem.id;
                    if ([BLOCKS.STONE, BLOCKS.COAL_ORE, BLOCKS.IRON_ORE, BLOCKS.GOLD_ORE, BLOCKS.FURNACE, BLOCKS.ANVIL].includes(tile.index)) {
                        if (id === BLOCKS.WOOD_PICKAXE) speed = 2; if (id === BLOCKS.STONE_PICKAXE) speed = 3; if (id === BLOCKS.IRON_PICKAXE) speed = 5;
                    }
                    if ([BLOCKS.LOG, BLOCKS.PLANKS, BLOCKS.WORKBENCH].includes(tile.index)) {
                        if (id === BLOCKS.WOOD_AXE) speed = 2; if (id === BLOCKS.STONE_AXE) speed = 3; if (id === BLOCKS.IRON_AXE) speed = 5;
                    }
                    if ([BLOCKS.DIRT, BLOCKS.GRASS].includes(tile.index)) { if (id === BLOCKS.IRON_SHOVEL) speed = 5; }
                }

                if (tile.index === BLOCKS.LEAVES) {
                    if (currentItem && currentItem.id === BLOCKS.SHEARS) this.mineBlock(tile, targetLayer, delta * 5);
                    else { 
                        this.tryDropSapling(tX, tY); 
                        if (Math.random() < 0.05) this.createDrop(tX*32, tY*32, BLOCKS.GOLDEN_APPLE, 1);
                        targetLayer.removeTileAt(tX, tY); 
                    }
                } else if (tile.index === BLOCKS.SLIME_BLOCK) {
                    this.mineBlock(tile, targetLayer, delta * 1.5);
                } else if (tile.index === BLOCKS.CACTUS) {
                    this.mineBlock(tile, targetLayer, delta * 2);
                } else if (tile.index === BLOCKS.CHEST) {
                    for(let i=0; i<3; i++) {
                         const loot = [BLOCKS.COAL, BLOCKS.IRON_INGOT, BLOCKS.GOLD_INGOT, BLOCKS.SLIMEBALL, BLOCKS.GOLDEN_APPLE, BLOCKS.APPLE, BLOCKS.DIAMOND][Phaser.Math.Between(0, 6)];
                         this.createDrop(tX*32, tY*32, loot, 1);
                    }
                    targetLayer.removeTileAt(tX, tY);
                } else if (tile.index === BLOCKS.DIAMOND_ORE) {
                    this.mineBlock(tile, targetLayer, delta * 0.5); 
                } else { this.mineBlock(tile, targetLayer, delta * speed); }
            }
        }
        
        this.wasClicking = isClicking;

        if (ptr.rightButtonDown() && inRange && currentItem) {
            const now = this.time.now;
            if (now - GAME_STATE.lastEatTime > 1000) { 
                 if (currentItem.id === BLOCKS.GOLDEN_APPLE || currentItem.id === BLOCKS.APPLE) {
                    const heal = currentItem.id === BLOCKS.GOLDEN_APPLE ? 50 : 15;
                    const hungerFill = currentItem.id === BLOCKS.GOLDEN_APPLE ? 50 : 20;
                    GAME_STATE.hp = Math.min(GAME_STATE.maxHp, GAME_STATE.hp + heal);
                    GAME_STATE.hunger = Math.min(GAME_STATE.maxHunger, GAME_STATE.hunger + hungerFill);
                    this.consumeItem();
                    GAME_STATE.lastEatTime = now;
                    this.showDamageText(this.player.x, this.player.y - 40, `+${heal} HP`, false); 
                    return;
                }
            }
            
            const nonPlaceable = [
                BLOCKS.RAW_IRON, BLOCKS.RAW_GOLD, BLOCKS.COAL, BLOCKS.SLIMEBALL, BLOCKS.IRON_INGOT, BLOCKS.GOLD_INGOT, BLOCKS.SHEARS, BLOCKS.SLIME_BOOTS, BLOCKS.GOLDEN_APPLE, BLOCKS.APPLE, BLOCKS.DIAMOND,
                BLOCKS.WOOD_PICKAXE, BLOCKS.WOOD_AXE, BLOCKS.WOOD_SWORD, BLOCKS.STONE_PICKAXE, BLOCKS.STONE_AXE, BLOCKS.STONE_SWORD, BLOCKS.IRON_PICKAXE, BLOCKS.IRON_AXE, BLOCKS.IRON_SHOVEL, BLOCKS.IRON_SWORD
            ];
            
            if (!nonPlaceable.includes(currentItem.id) && currentItem.count > 0) {
                if (!this.objectLayer.getTileAt(tX, tY) && !this.groundLayer.getTileAt(tX, tY)) {
                    const pRect = this.player.getBounds(); const tRect = new Phaser.Geom.Rectangle(this.marker.x, this.marker.y, TILE_SIZE, TILE_SIZE);
                    if (!Phaser.Geom.Rectangle.Overlaps(pRect, tRect)) {
                        if (currentItem.id === BLOCKS.BED) {
                            this.objectLayer.putTileAt(BLOCKS.BED, tX, tY);
                            GAME_STATE.spawnPoint = {x: tX * 32, y: tY * 32};
                            this.add.text(this.player.x, this.player.y - 50, "Đã lưu điểm hồi sinh!", { font: '16px Courier New', fill: '#FFF' }).destroyAfter(2000);
                            this.consumeItem();
                        } else if ([BLOCKS.TORCH, BLOCKS.LOG, BLOCKS.LEAVES, BLOCKS.WORKBENCH, BLOCKS.FURNACE, BLOCKS.ANVIL, BLOCKS.SLIME_BLOCK, BLOCKS.CACTUS, BLOCKS.SNOW, BLOCKS.CHEST, BLOCKS.CAMPFIRE].includes(currentItem.id)) {
                            this.objectLayer.putTileAt(currentItem.id, tX, tY); this.consumeItem();
                        } else {
                            const newTile = this.groundLayer.putTileAt(currentItem.id, tX, tY); newTile.setCollision(true); this.consumeItem();
                        }
                    }
                } else {
                    const tile = this.objectLayer.getTileAt(tX, tY);
                    if (tile && tile.index === BLOCKS.BED) {
                        const timeOfDay = (this.time.now % 120000) / 120000;
                        if (timeOfDay > 0.9 || timeOfDay < 0.2) { 
                             GAME_STATE.hp = GAME_STATE.maxHp;
                             this.add.text(this.player.x, this.player.y - 50, "Zzz... Sức khỏe đã hồi phục!", { font: '16px Courier New', fill: '#FFF' }).destroyAfter(2000);
                        } else {
                             this.add.text(this.player.x, this.player.y - 50, "Chỉ có thể ngủ vào ban đêm", { font: '16px Courier New', fill: '#FFF' }).destroyAfter(2000);
                        }
                    }
                }
            }
        }
    }

    consumeItem() {
        const item = GAME_STATE.inventory[GAME_STATE.selectedSlot]; item.count--; if (item.count <= 0) GAME_STATE.inventory[GAME_STATE.selectedSlot] = null;
    }

    mineBlock(tile, layer, progress) {
        if (!this.canPickUp(tile.index)) return; 
        GAME_STATE.isMining = true; GAME_STATE.miningProgress += progress;
        if (GAME_STATE.miningProgress >= 1000) {
            let dropID = tile.index;
            if (tile.index === BLOCKS.IRON_ORE) dropID = BLOCKS.RAW_IRON;
            else if (tile.index === BLOCKS.GOLD_ORE) dropID = BLOCKS.RAW_GOLD;
            else if (tile.index === BLOCKS.COAL_ORE) dropID = BLOCKS.COAL;
            else if (tile.index === BLOCKS.DIAMOND_ORE) dropID = BLOCKS.DIAMOND;
            
            this.addToInventory(dropID);
            
            const tool = GAME_STATE.inventory[GAME_STATE.selectedSlot];
            if (tool && tool.durability) { tool.durability--; if (tool.durability <= 0) { GAME_STATE.inventory[GAME_STATE.selectedSlot] = null; this.cameras.main.flash(50, 255, 0, 0); } }

            layer.removeTileAt(tile.x, tile.y); GAME_STATE.miningProgress = 0; GAME_STATE.isMining = false; this.cameras.main.shake(50, 0.005);
        }
    }

    canPickUp(tileIndex) { return GAME_STATE.inventory.some(i => i === null || (i && i.id === tileIndex && i.count < 64)); }

    addToInventory(id, dur, count = 1) {
        let slot = GAME_STATE.inventory.find(i => i && i.id === id && (!i.durability || i.durability === dur));
        if (slot && !dur) {
            slot.count += count;
        } else {
            let emptyIdx = GAME_STATE.inventory.findIndex(i => i === null);
            if (emptyIdx !== -1) {
                let names = { 
                    [BLOCKS.DIRT]:'Đất', [BLOCKS.GRASS]:'Cỏ', [BLOCKS.STONE]:'Đá', [BLOCKS.COAL_ORE]: 'Quặng Than', [BLOCKS.IRON_ORE]: 'Quặng Sắt', [BLOCKS.GOLD_ORE]: 'Quặng Vàng',
                    [BLOCKS.COAL]:'Than', [BLOCKS.RAW_IRON]:'Sắt Thô', [BLOCKS.RAW_GOLD]:'Vàng Thô', [BLOCKS.SLIMEBALL]:'Mật Slime',
                    [BLOCKS.LOG]:'Gỗ', [BLOCKS.LEAVES]:'Lá', [BLOCKS.TORCH]:'Đuốc', 
                    [BLOCKS.WORKBENCH]:'Bàn Chế Tạo', [BLOCKS.FURNACE]:'Lò Nung', [BLOCKS.ANVIL]:'Cái Đe', [BLOCKS.BRICK]:'Gạch Đá',
                    [BLOCKS.PLANKS]:'Ván Gỗ', [BLOCKS.IRON_INGOT]:'Thỏi Sắt', [BLOCKS.GOLD_INGOT]:'Thỏi Vàng', [BLOCKS.SHEARS]:'Kéo',
                    [BLOCKS.WOOD_PICKAXE]:'Cúp Gỗ', [BLOCKS.WOOD_AXE]:'Rìu Gỗ', [BLOCKS.WOOD_SWORD]:'Kiếm Gỗ',
                    [BLOCKS.STONE_PICKAXE]:'Cúp Đá', [BLOCKS.STONE_AXE]:'Rìu Đá', [BLOCKS.STONE_SWORD]:'Kiếm Đá',
                    [BLOCKS.IRON_PICKAXE]:'Cúp Sắt', [BLOCKS.IRON_AXE]:'Rìu Sắt', [BLOCKS.IRON_SHOVEL]:'Xẻng Sắt', [BLOCKS.IRON_SWORD]:'Kiếm Sắt',
                    [BLOCKS.SAPLING]:'Mầm Cây', [BLOCKS.SLIME_BOOTS]:'Giày Slime', [BLOCKS.SLIME_BLOCK]:'Khối Slime',
                    [BLOCKS.SAND]:'Cát', [BLOCKS.CACTUS]:'Xương Rồng', [BLOCKS.SNOW]:'Tuyết', [BLOCKS.GOLDEN_APPLE]:'Táo Vàng', [BLOCKS.APPLE]:'Táo', [BLOCKS.CHEST]:'Rương',
                    [BLOCKS.DIAMOND]:'Kim Cương', [BLOCKS.CAMPFIRE]:'Lửa Trại', [BLOCKS.BED]:'Giường'
                };
                let durability = dur || MAX_DURABILITY[id];
                GAME_STATE.inventory[emptyIdx] = { id: id, name: names[id] || 'Vật phẩm #' + id, count: count, durability: durability };
            }
        }
    }

    respawnPlayer() {
        let spawnX = Math.floor(WORLD_WIDTH / 2); let safeY = -1, found = false, attempts = 0;
        while (!found && attempts < 50) {
            for (let y = 0; y < WORLD_HEIGHT; y++) {
                const t = this.groundLayer.getTileAt(spawnX, y); if (t && t.index !== -1) { safeY = y * TILE_SIZE; found = true; break; }
            }
            if (!found) spawnX++; attempts++;
        }
        this.player.setPosition(found ? spawnX * TILE_SIZE + 16 : 100, found ? safeY - 50 : 0);
        this.player.setVelocity(0,0); GAME_STATE.hp = GAME_STATE.maxHp; this.prevVelocityY = 0;
    }
}

const config = {
    type: Phaser.AUTO, scale: { mode: Phaser.Scale.RESIZE, parent: document.body, width: '100%', height: '100%' },
    backgroundColor: '#87CEEB', pixelArt: true,
    physics: { default: 'arcade', arcade: { gravity: { y: PHYSICS_CONFIG.GRAVITY }, tileBias: 32 } },
    scene: [MenuScene, GameScene, UIScene]
};
const game = new Phaser.Game(config);
</script>
</body>
</html>
