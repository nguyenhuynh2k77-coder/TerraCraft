<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>TerraCraft HD - Optimized</title>
    <style>
        html, body { 
            width: 100%; height: 100%; margin: 0; padding: 0; 
            background: #111; overflow: hidden; 
            touch-action: none; user-select: none; -webkit-user-select: none;
        }
        canvas { display: block; }
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #0ff; font-family: monospace; font-size: 20px; pointer-events: none;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.80.0/dist/phaser.min.js"></script>
</head>
<body>

<div id="loading">Đang tải tài nguyên...</div>

<script>
window.onload = function() {
    // --- CẤU HÌNH ---
    const CFG = {
        TILE: 32, W: 300, H: 80,
        GRAVITY: 1200, WALK: 120, RUN: 240, JUMP: -500,
        SPAWN_RATE: 4000, MAX_MOBS: 12, DAY_LEN: 120000
    };

    // --- ID BLOCK ---
    const ID = {
        AIR:-1, DIRT:0, GRASS:1, STONE:2, COAL_ORE:3, IRON_ORE:4, GOLD_ORE:5, DIAMOND_ORE:6,
        LOG:7, LEAVES:8, TORCH:9, WORKBENCH:10, FURNACE:11, BRICK:12, PLANKS:13, ANVIL:14,
        SAPLING:15, SLIME_BLOCK:16, SAND:17, CACTUS:18, SNOW:19, CHEST:20, CAMPFIRE:21, BED:22,
        DOOR_CLOSED:23, DOOR_OPEN:24,
        // Items
        RAW_IRON:100, RAW_GOLD:101, COAL:102, IRON_INGOT:103, GOLD_INGOT:104, SLIMEBALL:105,
        GOLDEN_APPLE:106, APPLE:107, DIAMOND:108, DOOR_ITEM:109,
        // Tools
        WOOD_PICK:200, WOOD_AXE:201, WOOD_SWORD:202
    };

    // --- DỮ LIỆU GAME ---
    const GAME = {
        hp: 100, maxHp: 100, hunger: 100, maxHunger: 100,
        xp: 0, level: 1,
        inv: Array(10).fill(null), slot: 0,
        dead: false, mining: 0,
        input: { l:0, r:0, j:0, atk:0, use:0, drop:0 }
    };
    GAME.inv[0] = { id: ID.WOOD_SWORD, count: 1, dur: 50 };
    GAME.inv[1] = { id: ID.APPLE, count: 5 };

    // --- BỘ TẠO TEXTURE CAO CẤP (Asset Generator) ---
    class AssetGen {
        static init(scene) {
            const g = scene.make.graphics({x:0,y:0,add:false});
            
            // Hàm vẽ khối có chiều sâu (Bevel)
            const drawBlock = (idx, color, noiseAlpha=0.1) => {
                g.clear();
                // Nền
                g.fillStyle(color); g.fillRect(0,0,32,32);
                // Nhiễu hạt (Noise)
                g.fillStyle(0x000000, noiseAlpha);
                for(let i=0;i<16;i++) g.fillRect(Math.random()*30, Math.random()*30, 2, 2);
                // Hiệu ứng 3D (Viền sáng tối)
                g.lineStyle(2, 0xFFFFFF, 0.3); g.strokeRect(1,1,30,30); // Viền trong
                g.fillStyle(0x000000, 0.2); g.fillRect(0,30,32,2); g.fillRect(30,0,2,32); // Bóng đổ
                g.generateTexture('block_'+idx, 32, 32);
            };

            // Tạo Texture cho các Block
            drawBlock(ID.DIRT, 0x795548, 0.2);
            
            // Cỏ (Phức tạp hơn)
            g.clear(); g.fillStyle(0x795548); g.fillRect(0,0,32,32); // Đất
            g.fillStyle(0x4CAF50); g.fillRect(0,0,32,10); // Lớp cỏ trên
            for(let i=0;i<32;i+=4) if(Math.random()>0.5) g.fillRect(i,10,4,4); // Cỏ rủ xuống
            g.lineStyle(2, 0xFFFFFF, 0.2); g.beginPath(); g.moveTo(0,0); g.lineTo(32,0); g.stroke();
            g.generateTexture('block_'+ID.GRASS, 32, 32);

            drawBlock(ID.STONE, 0x808080, 0.3);
            drawBlock(ID.SAND, 0xE6D690, 0.1);
            drawBlock(ID.SNOW, 0xFFFFFF, 0.05);
            drawBlock(ID.LOG, 0x5D4037, 0.4);
            drawBlock(ID.PLANKS, 0xA1887F, 0.1);
            drawBlock(ID.BRICK, 0x757575, 0.1);
            
            // Lá cây (Trong suốt 1 chút)
            g.clear(); g.fillStyle(0x388E3C); g.fillRect(0,0,32,32);
            g.fillStyle(0x66BB6A); for(let i=0;i<20;i++) g.fillRect(Math.random()*28, Math.random()*28, 4, 4);
            g.generateTexture('block_'+ID.LEAVES, 32, 32);

            // Quặng (Ore)
            const drawOre = (id, baseColor, gemColor) => {
                drawBlock(id, baseColor, 0.3); // Vẽ nền đá trước
                // Vẽ đè hạt quặng lên texture vừa tạo
                const tex = scene.textures.get('block_'+id);
                const ctx = tex.getSourceImage().getContext('2d');
                ctx.fillStyle = gemColor;
                for(let i=0; i<4; i++) ctx.fillRect(8 + Math.random()*16, 8 + Math.random()*16, 6, 6);
                tex.refresh();
            };
            drawOre(ID.COAL_ORE, 0x808080, '#222');
            drawOre(ID.IRON_ORE, 0x808080, '#E0C0A0');
            drawOre(ID.GOLD_ORE, 0x808080, '#FFD700');
            drawOre(ID.DIAMOND_ORE, 0x808080, '#00FFFF');

            // Cửa
            g.clear(); g.fillStyle(0xA1887F); g.fillRect(4,0,24,32); 
            g.lineStyle(2, 0x5D4037); g.strokeRect(4,0,24,32);
            g.fillStyle(0xFFD700); g.fillCircle(22, 16, 3); // Tay nắm
            g.generateTexture('block_'+ID.DOOR_CLOSED, 32, 32);
            
            g.clear(); g.fillStyle(0x5D4037); g.fillRect(2,0,6,32); // Cửa mở (nhìn nghiêng)
            g.generateTexture('block_'+ID.DOOR_OPEN, 32, 32);

            // Xương rồng
            g.clear(); g.fillStyle(0x2E7D32); g.fillRect(4,0,24,32);
            g.fillStyle(0x1B5E20); for(let i=4; i<32; i+=4) g.fillRect(4,i,2,2);
            g.generateTexture('block_'+ID.CACTUS, 32, 32);

            // Các block khác (Fallback simple)
            drawBlock(ID.WORKBENCH, 0x8D6E63);
            drawBlock(ID.FURNACE, 0x424242);
            drawBlock(ID.CHEST, 0xCD853F);

            // ITEMS & TOOLS
            const drawItem = (name, color) => {
                g.clear(); g.fillStyle(color); g.fillCircle(16,16,10); 
                g.lineStyle(2,0xFFFFFF); g.strokeCircle(16,16,10);
                g.generateTexture(name, 32, 32);
            }
            drawItem('item_apple', 0xFF0000);
            drawItem('item_slime', 0x00FF00);
            drawItem('item_tool', 0x8B4513);

            // PLAYER & MOBS
            g.clear(); g.fillStyle(0xFFCC80); g.fillRect(8,0,16,10); // Đầu
            g.fillStyle(0x00BFFF); g.fillRect(8,10,16,12); // Áo
            g.fillStyle(0x1A237E); g.fillRect(8,22,16,10); // Quần
            g.generateTexture('player', 32, 32);

            g.clear(); g.fillStyle(0x76FF03, 0.8); g.fillRect(4,10,24,22);
            g.fillStyle(0x33691E); g.fillRect(8,16,4,4); g.fillRect(20,16,4,4); // Mắt
            g.generateTexture('slime', 32, 32);

            // PARTICLES
            g.clear(); g.fillStyle(0x4FC3F7); g.fillRect(0,0,3,8); g.generateTexture('rain', 3, 8);
            g.clear(); g.fillStyle(0xFFFFFF); g.fillRect(0,0,4,4); g.generateTexture('snow', 4, 4);
        }
    }

    // --- GAME SCENE ---
    class GameScene extends Phaser.Scene {
        constructor() { super('Game'); }
        preload() { AssetGen.init(this); document.getElementById('loading').style.display='none'; }
        
        create() {
            this.W = CFG.W * CFG.TILE; this.H = CFG.H * CFG.TILE;
            this.physics.world.setBounds(0, 0, this.W, this.H);
            
            // Tạo nền trời Gradient (Đẹp hơn màu đơn)
            this.sky = this.add.graphics();
            this.updateSky(0.5); // Init sky

            // Map
            const map = this.make.tilemap({ tileWidth: 32, tileHeight: 32, width: CFG.W, height: CFG.H });
            // Chúng ta dùng mảng tileset thay vì 1 ảnh duy nhất để đẹp hơn
            const tileset = map.addTilesetImage('block_'+ID.DIRT); // Placeholder, logic vẽ sẽ dùng tay
            
            this.ground = map.createBlankLayer('G', tileset);
            this.obj = map.createBlankLayer('O', tileset);
            this.ground.setCollisionByExclusion([-1]);
            this.obj.setCollision([ID.SLIME_BLOCK, ID.CACTUS, ID.DOOR_CLOSED]); 

            this.genMap(); // Tạo map

            // Player
            this.p = this.physics.add.sprite(200, 0, 'player').setDepth(10);
            this.p.body.setSize(16, 28).setOffset(8, 2);
            this.physics.add.collider(this.p, this.ground);
            this.physics.add.collider(this.p, this.obj, (p,t)=>{ if(t.index===ID.CACTUS) this.hurt(1); });

            this.cameras.main.startFollow(this.p, true, 0.1, 0.1).setZoom(1.3).setBounds(0,0,this.W,this.H);
            this.hand = this.add.sprite(0,0,'item_tool').setDepth(11).setVisible(false).setScale(0.6);

            // Groups
            this.drops = this.physics.add.group({dragX:1000, bounceY:0.2});
            this.physics.add.collider(this.drops, this.ground);
            this.physics.add.collider(this.drops, this.obj);
            this.physics.add.overlap(this.p, this.drops, (p,d)=>this.pickup(d));

            this.mobs = this.physics.add.group();
            this.physics.add.collider(this.mobs, this.ground);
            this.physics.add.collider(this.mobs, this.obj, (m,t)=>{ if(t.index===ID.CACTUS) this.mobHurt(m,5); });
            this.physics.add.overlap(this.p, this.mobs, (p,m)=>this.hitByMob(m));

            // Particles (Tối ưu)
            this.rain = this.add.particles(0,0,'rain',{speedY:{min:400,max:600}, quantity:2, frequency:30, emitting:false});
            this.snow = this.add.particles(0,0,'snow',{speedY:{min:50,max:100}, quantity:2, frequency:80, emitting:false});
            const camW = this.cameras.main.width;
            this.rain.setEmitZone({source:new Phaser.Geom.Rectangle(-camW/2, -300, camW, 1)});
            this.snow.setEmitZone({source:new Phaser.Geom.Rectangle(-camW/2, -300, camW, 1)});

            // Marker
            this.marker = this.add.rectangle(0,0,32,32).setStrokeStyle(2, 0xFFFF00).setOrigin(0).setVisible(false);

            // Inputs
            this.cursors = this.input.keyboard.createCursorKeys();
            this.keys = this.input.keyboard.addKeys('E,Q,ONE,TWO,THREE,FOUR,FIVE');
            
            this.time.addEvent({delay: CFG.SPAWN_RATE, callback: this.spawnMob, callbackScope: this, loop: true});
            
            this.scene.launch('UI'); // Chạy UI
        }

        // Tự vẽ map thủ công bằng texture đẹp
        genMap() {
            // Hàm vẽ tile vào layer với texture tương ứng
            const place = (layer, x, y, id) => {
                const t = layer.putTileAt(id, x, y);
                // Gán texture riêng cho tile này (Phaser feature)
                t.properties.texture = 'block_'+id; 
            };

            for(let x=0; x<CFG.W; x++) {
                let h = 40 + Math.floor(Math.sin(x/20)*8 + Math.cos(x/8)*4);
                for(let y=0; y<CFG.H; y++) {
                    if(y===h) place(this.ground, x, y, x<100?ID.GRASS:(x>200?ID.SNOW:ID.SAND));
                    else if(y>h) place(this.ground, x, y, y>h+5?ID.STONE:ID.DIRT);
                }
                // Cây & Xương rồng
                if(x%5===0 && Math.random()<0.2) {
                    if(x<100) { place(this.obj, x, h-1, ID.LOG); place(this.obj, x, h-2, ID.LEAVES); }
                    else if(x>100 && x<200) place(this.obj, x, h-1, ID.CACTUS);
                }
            }
            
            // QUAN TRỌNG: Thay thế texture mặc định bằng texture đẹp đã tạo
            this.ground.forEachTile(t => { if(t.index!==-1) t.index = t.index; /* trigger redraw */ }); // Hacky force update
            // Do Phaser Tilemap dùng chung 1 texture, ta dùng Sprite thay thế cho lớp Object để đẹp hơn nếu cần, 
            // nhưng để tối ưu ta chấp nhận dùng tilemap với texture chuẩn.
            // Ở đây tôi dùng trick: Swap texture lúc render (nâng cao), nhưng để đơn giản cho file 1 HTML,
            // tôi sẽ dùng texture DIRT làm base, các khối khác sẽ vẽ đè lên bằng Sprite tĩnh nếu cần thiết.
            // TUY NHIÊN: Để giữ code <1000 dòng, ta sẽ dùng 1 tileset lớn chứa tất cả texture.
            // Phần AssetGen đã tạo texture riêng, giờ ta gộp lại thành 1 tileset lớn (Atlas) thì tốt hơn.
            // Nhưng cách đơn giản nhất: Ta không dùng map.createBlankLayer mà dùng Group Image cho đẹp? KHÔNG, sẽ lag.
            
            // FIX: Để hiển thị đồ họa đẹp trên Tilemap, ta cần gán lại Texture cho từng tile.
            // Phaser không hỗ trợ multi-texture tilemap dễ dàng.
            // GIẢI PHÁP: Ta vẽ TẤT CẢ block vào 1 Canvas lớn (Tileset) lúc init.
            
            // Cập nhật lại AssetGen để tạo 1 ảnh tileset duy nhất (Atlas).
            this.rebuildTilesetTexture();
        }

        rebuildTilesetTexture() {
            // Tạo 1 canvas dài chứa tất cả block
            const totalIDs = 30;
            const tex = this.textures.createCanvas('atlas', totalIDs*32, 32);
            const ctx = tex.getContext();
            for(let id=0; id<totalIDs; id++) {
                if(this.textures.exists('block_'+id)) {
                    const img = this.textures.get('block_'+id).getSourceImage();
                    ctx.drawImage(img, id*32, 0);
                }
            }
            tex.refresh();
            // Gán lại tileset cho layer
            const tileset = this.map.addTilesetImage('atlas', null, 32, 32);
            this.ground.tileset = [tileset];
            this.obj.tileset = [tileset];
        }

        update(time, delta) {
            if(GAME.dead) return;

            // Môi trường
            const cycle = (time % CFG.DAY_LEN) / CFG.DAY_LEN;
            this.updateSky(cycle);
            
            const px = this.p.x;
            this.rain.setPosition(px, 0); this.snow.setPosition(px, 0);
            if(px < 3200) { this.rain.start(); this.snow.stop(); }
            else if(px > 6400) { this.snow.start(); this.rain.stop(); }
            else { this.rain.stop(); this.snow.stop(); }

            // Di chuyển
            const spd = this.keys.SHIFT?.isDown ? CFG.RUN : CFG.WALK;
            if(this.cursors.left.isDown || GAME.input.l) { this.p.setVelocityX(-spd); this.p.setFlipX(true); }
            else if(this.cursors.right.isDown || GAME.input.r) { this.p.setVelocityX(spd); this.p.setFlipX(false); }
            else this.p.setVelocityX(0);
            
            if((this.cursors.up.isDown || GAME.input.j) && this.p.body.onFloor()) this.p.setVelocityY(CFG.JUMP);

            // Tay cầm
            const item = GAME.inv[GAME.slot];
            if(item) {
                this.hand.setVisible(true).setTexture(item.id<100?'block_'+item.id:'item_tool');
                this.hand.setPosition(this.p.x + (this.p.flipX?-12:12), this.p.y+6);
                this.hand.setFlipX(this.p.flipX);
            } else this.hand.setVisible(false);

            this.handleInput();
        }

        updateSky(cycle) {
            this.sky.clear();
            // Gradient giả lập
            const isDay = cycle > 0.25 && cycle < 0.75;
            const c1 = isDay ? 0x87CEEB : 0x000033;
            const c2 = isDay ? 0xE0F7FA : 0x000000;
            this.sky.fillGradientStyle(c1, c1, c2, c2, 1);
            this.sky.fillRect(0,0,this.scale.width, this.scale.height);
        }

        handleInput() {
            const ptr = this.input.activePointer;
            const wp = ptr.positionToCamera(this.cameras.main);
            let tx = Math.floor(wp.x/32), ty = Math.floor(wp.y/32);
            
            if(GAME.input.atk || GAME.input.use) {
                tx = Math.floor((this.p.x + (this.p.flipX?-32:32))/32);
                ty = Math.floor(this.p.y/32);
            }
            this.marker.setPosition(tx*32, ty*32).setVisible(true);

            // MINE / ATTACK
            if((ptr.isDown && !this.lastPtr) || GAME.input.atk) {
                let hit = false;
                this.mobs.children.iterate(m => {
                    if(m && Phaser.Geom.Rectangle.Overlaps(m.getBounds(), this.marker.getBounds())) {
                        this.mobHurt(m, 5); hit = true;
                    }
                });
                if(!hit) {
                    const t = this.obj.getTileAt(tx, ty) || this.ground.getTileAt(tx, ty);
                    if(t) {
                        GAME.mining++;
                        this.cameras.main.shake(50, 0.001);
                        this.hand.angle = this.p.flipX ? -45 : 45;
                        if(GAME.mining > 20) {
                            this.dropItem(tx*32, ty*32, t.index);
                            if(t.tilemapLayer === this.obj) this.obj.removeTileAt(tx, ty);
                            else this.ground.removeTileAt(tx, ty);
                            GAME.mining = 0;
                        }
                    }
                }
            } else {
                this.hand.angle = 0; GAME.mining = 0;
            }

            // PLACE / USE
            if((ptr.rightButtonDown() && !this.lastR) || GAME.input.use) {
                const item = GAME.inv[GAME.slot];
                const tObj = this.obj.getTileAt(tx, ty);
                
                // Cửa
                if(tObj && tObj.index === ID.DOOR_CLOSED) {
                    this.obj.putTileAt(ID.DOOR_OPEN, tx, ty).setCollision(false);
                } else if(tObj && tObj.index === ID.DOOR_OPEN) {
                    this.obj.putTileAt(ID.DOOR_CLOSED, tx, ty).setCollision(true);
                }
                // Đặt Block
                else if(item && item.id < 100 && !tObj) {
                    if(!Phaser.Geom.Rectangle.Overlaps(this.p.getBounds(), this.marker.getBounds())) {
                        if(item.id === ID.CACTUS) {
                            const below = this.ground.getTileAt(tx, ty+1);
                            if(below && below.index === ID.SAND) {
                                this.obj.putTileAt(ID.CACTUS, tx, ty); this.consume();
                            }
                        } else {
                            this.obj.putTileAt(item.id, tx, ty); this.consume();
                        }
                    }
                }
            }
            // Drop
            if(GAME.input.drop) {
                const it = GAME.inv[GAME.slot];
                if(it) { this.dropItem(this.p.x, this.p.y-20, it.id); this.consume(); }
            }

            this.lastPtr = ptr.isDown; this.lastR = ptr.rightButtonDown();
            GAME.input.atk = false; GAME.input.use = false; GAME.input.drop = false;
        }

        consume() {
            const i = GAME.inv[GAME.slot];
            if(i) { i.count--; if(i.count<=0) GAME.inv[GAME.slot] = null; }
        }

        dropItem(x, y, id) {
            const tex = id<100 ? 'block_'+id : (id===ID.SLIMEBALL?'item_slime':'item_tool');
            const d = this.drops.create(x, y, tex).setDisplaySize(16,16);
            d.setData('id', id).setData('t', this.time.now + 1000);
            d.setVelocity(Math.random()*100-50, -200);
        }

        pickup(d) {
            if(this.time.now < d.getData('t') || GAME.dead) return;
            const id = d.getData('id');
            let done = false;
            for(let i=0; i<10; i++) {
                if(GAME.inv[i] && GAME.inv[i].id === id) { GAME.inv[i].count++; done=true; break; }
            }
            if(!done) {
                for(let i=0; i<10; i++) if(!GAME.inv[i]) { GAME.inv[i]={id:id, count:1}; done=true; break; }
            }
            if(done) d.destroy();
        }

        spawnMob() {
            if(this.mobs.countActive() < CFG.MAX_MOBS && !GAME.dead) {
                const x = Phaser.Math.Between(Math.max(0, this.p.x-500), Math.min(this.W, this.p.x+500));
                if(Math.abs(x - this.p.x) > 300) {
                    const m = this.mobs.create(x, 100, 'slime').setBounce(0.5).setCollideWorldBounds(true);
                    m.hp = 20;
                }
            }
        }

        mobHurt(m, dmg) {
            m.hp -= dmg; m.setTint(0xFF0000); m.setVelocityY(-200);
            this.time.delayedCall(150, ()=>m.clearTint());
            if(m.hp<=0) { this.dropItem(m.x, m.y, ID.SLIMEBALL); m.destroy(); }
        }

        hitByMob(m) { this.hurt(10); m.setVelocityX(m.x > this.p.x ? 100 : -100); }

        hurt(dmg) {
            if(GAME.dead) return;
            GAME.hp -= dmg;
            this.cameras.main.shake(100, 0.01);
            if(GAME.hp <= 0) {
                GAME.dead = true;
                this.p.setTint(0xFF0000);
                GAME.inv.forEach((it, i) => {
                    if(it) for(let k=0;k<it.count;k++) this.dropItem(this.p.x, this.p.y, it.id);
                    GAME.inv[i] = null;
                });
                this.scene.get('UI').showDeath(true);
            }
        }

        respawn() {
            GAME.dead = false; GAME.hp = 100;
            this.p.clearTint(); this.p.setPosition(200, 0); this.p.setVelocity(0,0);
            this.scene.get('UI').showDeath(false);
        }
    }

    // --- UI SCENE (SAFE MODE) ---
    class UIScene extends Phaser.Scene {
        constructor() { super('UI'); }
        create() {
            this.isReady = false; // Cờ an toàn
            try {
                const W = this.scale.width, H = this.scale.height;
                
                // Bars
                this.add.text(10, 10, 'HP', {fontSize:12});
                this.hpBar = this.add.rectangle(35, 18, 150, 12, 0xFF0000).setOrigin(0);
                this.add.rectangle(35, 18, 150, 12).setStrokeStyle(1, 0xFFFFFF).setOrigin(0);

                // Slots
                this.slots = [];
                const sx = (W - 10*36)/2;
                for(let i=0; i<10; i++) {
                    const c = this.add.container(sx + i*36, H-40);
                    const bg = this.add.rectangle(0,0,32,32,0x222222).setStrokeStyle(1, 0x888888);
                    const ico = this.add.image(0,0,'item_tool').setDisplaySize(20,20).setVisible(false);
                    const txt = this.add.text(8,8,'',{fontSize:10}).setOrigin(1);
                    c.add([bg, ico, txt]);
                    c.setInteractive(new Phaser.Geom.Rectangle(-16,-16,32,32), Phaser.Geom.Rectangle.Contains)
                     .on('pointerdown', ()=>GAME.slot=i);
                    this.slots.push({bg, ico, txt});
                }

                // Controls
                const btn = (x,y,t,fn) => this.add.text(x,y,t,{fontSize:20, backgroundColor:'#333', padding:{x:8,y:8}}).setOrigin(0.5).setInteractive().on('pointerdown',fn);
                btn(40, H-50, '<', ()=>GAME.input.l=1).on('pointerup', ()=>GAME.input.l=0);
                btn(90, H-50, '>', ()=>GAME.input.r=1).on('pointerup', ()=>GAME.input.r=0);
                btn(W-40, H-50, '^', ()=>GAME.input.j=1).on('pointerup', ()=>GAME.input.j=0);
                btn(W-90, H-50, 'A', ()=>GAME.input.atk=1);
                btn(W-40, H-100, 'U', ()=>GAME.input.use=1);
                btn(W-90, H-100, 'D', ()=>GAME.input.drop=1);

                // Death
                this.deathPnl = this.add.container(W/2, H/2).setVisible(false);
                this.deathPnl.add([
                    this.add.rectangle(0,0,1000,1000,0x000000,0.8),
                    this.add.text(0,-30,'YOU DIED', {fontSize:40, color:'red'}).setOrigin(0.5),
                    this.add.text(0,30,'[ RESPAWN ]', {fontSize:20}).setOrigin(0.5).setInteractive().on('pointerdown', ()=>this.scene.get('Game').respawn())
                ]);

                this.isReady = true; // Đánh dấu đã xong
            } catch(e) { console.error(e); }
        }

        showDeath(v) { if(this.isReady) this.deathPnl.setVisible(v); }

        update() {
            if(!this.isReady) return; // Chặn lỗi undefined
            
            // Cập nhật HP Bar
            this.hpBar.width = (GAME.hp/GAME.maxHp)*150;

            // Cập nhật Slots
            for(let i=0; i<10; i++) {
                const s = this.slots[i];
                const it = GAME.inv[i];
                s.bg.setStrokeStyle(2, GAME.slot===i ? 0x00FF00 : 0x888888);
                if(it) {
                    s.ico.setVisible(true).setTexture(it.id<100?'block_'+it.id : (it.id===ID.SLIMEBALL?'item_slime':'item_tool'));
                    s.txt.setText(it.count>1 ? it.count : '');
                } else {
                    s.ico.setVisible(false); s.txt.setText('');
                }
            }
        }
    }

    new Phaser.Game({
        type: Phaser.AUTO,
        scale: { mode: Phaser.Scale.RESIZE, parent: document.body, width: '100%', height: '100%' },
        pixelArt: true,
        physics: { default: 'arcade', arcade: { gravity: { y: CFG.GRAVITY } } },
        scene: [GameScene, UIScene]
    });
};
</script>
</body>
</html>
